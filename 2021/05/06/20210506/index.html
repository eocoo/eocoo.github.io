<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>算法设计 排序 | Echo</title>
  <meta name="author" content="shanhm1991">
  
  <meta name="description" content="排序即将一组对象按照某种逻辑顺序重新排列的过程，通常，整理数据的第一步就是进行排序，在早期时代，大家普遍认为30%的计算周期都用在了排序上，如今这个比例降低了，可能的原因之一是如今的排序算法更加高效，而并非排序的重要性降低了。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="算法设计 排序"/>
  <meta property="og:site_name" content="Echo"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Echo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-147251181-1', 'auto');
	ga('send', 'pageview');

</script>


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header id="header" class="inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="alignleft">
  <h1><a href="/">Echo</a></h1>
  <span style="color:#ADA5A0; height:20px;line-height:30px;">心怀热爱，不问终点，凛冬散尽，星河长明</span>
  <h2><font style="color: #999;">articles:  97 &nbsp;&nbsp;&nbsp; views: <span id="busuanzi_value_site_uv"></span></font></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/about">Abount</a></li>
    
      <li><a href="/books">Books</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>

<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-20210506" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-05-05T16:00:00.000Z"><a href="/2021/05/06/20210506/">2021-05-06</a></time>
      
      

  
  
    <h1 class="p-name title" itemprop="headline name">
        算法设计 排序
    </h1>
    
    
  
  
  


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


   <span style="line-height:35px; height:35px; ">  </span>

   <font style="color: #999;"> words: 3.6k  &nbsp;&nbsp; views: <span id="busuanzi_value_page_pv"></span> &nbsp;&nbsp; time: 15min</font>
   
   
  
  <div class="categories">
    <a href="/categories/算法设计/">算法设计</a>
  </div>


   
   

   
   <hr style="background-color: #ddd; height:1px; border:none;" /><br>
   


    </header>
      
    <div class="e-content entry" itemprop="articleBody">
      
        <p>排序即将一组对象按照某种逻辑顺序重新排列的过程，通常，整理数据的第一步就是进行排序，在早期时代，大家普遍认为30%的计算周期都用在了排序上，如今这个比例降低了，可能的原因之一是如今的排序算法更加高效，而并非排序的重要性降低了。<br><a id="more"></a></p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这里先设计一个排序工具类<code>Sorts</code>，提供对<code>List</code>进行排序的接口，同时支持对排序策略的选择，默认从小到大进行排序，另外，也可以通过设置<code>Comparator</code>进行反向排序</p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/Echo/blob/master/src/main/java/io/github/echo/algorithms/sort/</span><span class="caption">Sorts.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, String algorithm)</span> </span>&#123;</span><br><span class="line">    doSort(list, algorithm, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, String algorithm, Comparator&lt;? <span class="keyword">super</span> T&gt; comp)</span> </span>&#123;</span><br><span class="line">    doSort(list, algorithm, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">doSort</span><span class="params">(List&lt;E&gt; list, String algorithm, Comparator&lt;? <span class="keyword">super</span> E&gt; comp)</span> </span>&#123;</span><br><span class="line">    LOGGER.debug(<span class="string">"before sort: &#123;&#125;"</span>, list); </span><br><span class="line"></span><br><span class="line">    Object[] array = list.toArray();</span><br><span class="line">    <span class="keyword">switch</span>(algorithm)&#123;</span><br><span class="line">    <span class="keyword">case</span> ALGORITHM_SELECT: sort_select(array, comp); <span class="keyword">break</span>;            <span class="comment">// 冒泡排序</span></span><br><span class="line">    <span class="keyword">case</span> ALGORITHM_INSERT_SWAP: sort_insert_swap(array, comp); <span class="keyword">break</span>;  <span class="comment">// 插入排序</span></span><br><span class="line">    <span class="keyword">case</span> ALGORITHM_INSERT_MOVE: sort_insert_move(array, comp); <span class="keyword">break</span>;  <span class="comment">// 插入排序</span></span><br><span class="line">    <span class="keyword">case</span> ALGORITHM_INSERT_XIER: sort_xier(array, comp); <span class="keyword">break</span>;         <span class="comment">// 希尔排序</span></span><br><span class="line">    <span class="keyword">case</span> ALGORITHM_MERGE: sort_merge(array, comp); <span class="keyword">break</span>;              <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="keyword">case</span> ALGORITHM_QUICK: sort_quick(array, comp); <span class="keyword">break</span>;              <span class="comment">// 快速排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListIterator&lt;E&gt; i = list.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (Object e : array) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后内部定义两个操作，即比较<code>comp</code>和交换<code>swap</code>，通过统一的日志来比较各个排序策略的复杂度问题，即比较和交换的次数</p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/Echo/blob/master/src/main/java/io/github/echo/algorithms/sort/</span><span class="caption">Sorts.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">comp</span><span class="params">(Object[] array, <span class="keyword">int</span> a, <span class="keyword">int</span> b, Comparator comp)</span> </span>&#123;</span><br><span class="line">	LOGGER.debug(String.format(<span class="string">"%60s %2s comp：%2s&lt;&gt;%2s ([%2s]&lt;&gt;[%2s])"</span>, <span class="string">" "</span>, ++times_compare, array[a], array[b], a, b)); </span><br><span class="line">	<span class="keyword">if</span>(comp != <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> comp.compare(array[a], array[b]);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ((Comparable)array[a]).compareTo(array[b]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Object[] array, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    Object t = array[a];</span><br><span class="line">    array[a] = array[b];</span><br><span class="line">    array[b] = t;</span><br><span class="line">    LOGGER.debug(String.format(<span class="string">"%2s swap：%2s&lt;&gt;%2s ([%2s]&lt;&gt;[%2s]) = %s"</span>, ++times_swap, array[b], array[a], a, b, Arrays.toString(array))); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面构造一个<code>List[5, 2, 10, 7, 6, 3, 8, 4]</code>，然后分别对不同的排序算法进行排序分析</p>
<h4 id="1-选择排序-冒泡排序"><a href="#1-选择排序-冒泡排序" class="headerlink" title="1. 选择排序/冒泡排序"></a>1. 选择排序/冒泡排序</h4><p>选择排序是一种很容易理解和实现的简单排序：首先，从数组中找出最小的元素，并将它与数组的第一个元素交换位置；然后，再从剩下的元素中找到最小的元素，并将它与数组的第二个元素交换位置；如此往复，直到将整个数组排序   </p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/Echo/blob/master/src/main/java/io/github/echo/algorithms/sort/</span><span class="caption">Sorts.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort_select</span><span class="params">(Object[] array, Comparator comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(comp(array, i, j, comp) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                swap(array, i ,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/20210506/20210506.1.jpg" alt=""></p>
<p>选择排序的<font color="#E51508">时间复杂度与输入的初始顺序无关</font>，即无论以怎样的初始顺序输入，其比较和交换次数都是固定的。</p>
<p>由于每次交换都能排定一个元素，所以最多只需要寻找并交换 $N-1$ 次，但<font color="#E51508">每次遍历寻找最小元素的操作，并不能为下一次遍历提供什么有用信息</font>，因此即便输入一个已经排序的数组，同样需要比较次数：$(N-1) + (N-2) + … + 1 = N(N-1)/2$ </p>
<p>.<font color="gray">这里写的冒泡实现，比较次数一样，而交换次数偏多，不过思路是类似的，只是没有用一个临时变量来记录每次寻找的最小值</font></p>
<h4 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h4><p>可以类似于打牌，每次将一张牌插入到前面已经有序的牌中，不过在实现中，为了给插入的元素腾出位置，每次插入之前需要将插入位置及之后的所有元素都向右移动一位</p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/Echo/blob/master/src/main/java/io/github/echo/algorithms/sort/</span><span class="caption">Sorts.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort_insert_swap</span><span class="params">(Object[] array, Comparator comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; comp(array, j, j - <span class="number">1</span>, comp) &lt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">            swap(array, j-<span class="number">1</span> ,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/20210506/20210506.2.jpg" alt=""></p>
<p>与选择排序一样，当前索引左边的所有元素都是有序的，但是它们的最终位置还不确定，为了给更小的元素腾出位置，它们可能还会被移动，当索引到达数组最右端时，数组排序也就完成了。</p>
<p>不同的是，插入排序的<font color="#E51508">时间复杂度与输入的初始顺序相关</font>，比如对于长度为 $N$ 的数组，最好情况下如果已经排序，那么只需要 $N-1$ 次比较和 $0$ 次交换，相反，最差情况是对逆序数组进行排序，那么就需要 $N(N-1)/2$ 次比较，以及 $N(N-1)/2$ 次交换，如果取平均复杂度，那就是好坏参半，可以约为 $\in N^2/4$</p>
<p>另外，对于插入排序，可以通过移动操作代替交换操作来降低操作的次数，因为交换每次只能交换相邻的元素，而如果用一个临时变量来记住待插入的位置，就可以将多次交换操作合并为一个整体的移动操作</p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/Echo/blob/master/src/main/java/io/github/echo/algorithms/sort/</span><span class="caption">Sorts.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort_insert_move</span><span class="params">(Object[] array, Comparator comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; comp(array, i, j - <span class="number">1</span>, comp) &lt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">            index = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">            move(array, index ,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(Object[] array, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    Object t = array[b];</span><br><span class="line">    System.arraycopy(array, a, array, a + <span class="number">1</span>, b - a);</span><br><span class="line">    array[a] = t;</span><br><span class="line">    LOGGER.debug(String.format(<span class="string">"%2s move： %s([%s]-&gt;[%s]) = %s"</span>, ++times_swap, t, b, a, Arrays.toString(array)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3. 希尔排序"></a>3. 希尔排序</h4><p>由于插入排序的时间复杂度与输入的初始顺序强相关，那么<font color="#E51508">对于一个数组，如果能提高其局部有序性，就可以降低在插入排序时的复杂度</font>，希尔排序就是基于这个想法对插入排序进行了改进。</p>
<p>具体做法是将原数组按照固定间隔 h 拆分成若干个独立的子数组，然后分别对这些子数组进行排序，这些子数组的排序即提高了局部有序性，我们将这种子数组都有序的数组称为 h 有序。</p>
<p>对于大规模的数组，如果最小元素在数组尽头，那么通过插入排序要将它移到正确的位置就需要 N-1 次移动，而通过对数组进行 h 间隔拆分，如果 h 很大，那么就能将元素移动到很远的地方，然后再逐步减小 h 进行拆分，这样前面大 h 的排序结果就能为后面更小 h 的排序创造方便，并从整体上降低比较和交换次数，如果最终 h 为 1，那么就能将数组完成排序。</p>
<p>显然，希尔排序的性能取决于 h 序列的选择，不仅取决于 h 的大小，还取决于 h 之间的公因子等数学性质，下面令 $h = h * 3 + 1$</p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/Echo/blob/master/src/main/java/io/github/echo/algorithms/sort/</span><span class="caption">Sorts.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort_xier</span><span class="params">(Object[] array, Comparator comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h &lt; array.length / <span class="number">3</span>)&#123; </span><br><span class="line">        h = h * <span class="number">3</span> + <span class="number">1</span>; <span class="comment">// 1, 4, 13, 40, 121,364, 1093 ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        LOGGER.debug(<span class="string">"compare interval: &#123;&#125;"</span>, h); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; comp(array, j, j - h, comp) &lt; <span class="number">0</span>; j -= h)&#123;</span><br><span class="line">                swap(array, j-h ,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/20210506/20210506.5.jpg" alt=""></p>
<p>上面示例中的算法，在已知最坏情况下所需的比较次数大约为 $N^{3/2}$，希尔排序通过一个小小的改变就提高了插入排序的速度，并打破了平方级别的复杂度屏障，并且数组越大，优势越明显。</p>
<p>至于希尔排序复杂度的数学证明问题已经超出了这里的讨论范围，不过可以尝试证明：<strong>当一个 h 有序的数组按照增幅 k 排序之后，其仍然是 h 有序的</strong></p>
<h4 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h4><p>归并排序是分治思想的一种体现，要将一个数组排序，可以先递归地将它分为两半分别排序，然后再逐步将结果归并起来。</p>
<p>这样<font color="#E51508">在每次合并操作时，都有一个前提，即左右两边数组都分别是有序的</font>，于是，在合并的实现过程中，可以通过判断来省略一些步骤，比如当左子数组的最右元素，大于右子数组的最左元素时，就可以直接判定原数组已经有序，无需再进行 merge 操作，另外，如果在 merge 的过程中，发现一边数组的元素已经全部用完，则可以直接将另一边数组剩余的元素进行整体拷贝，无需再逐个比较。</p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/Echo/blob/master/src/main/java/io/github/echo/algorithms/sort/</span><span class="caption">Sorts.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort_merge</span><span class="params">(Object[] array, Comparator comp)</span> </span>&#123;</span><br><span class="line">    Object[] temp = array.clone();</span><br><span class="line">    recursion_mid(array, temp, <span class="number">0</span>, array.length - <span class="number">1</span>, comp);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion_mid</span><span class="params">(Object[] array, Object[] temp, <span class="keyword">int</span> low, <span class="keyword">int</span> high, Comparator comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    LOGGER.debug(<span class="string">"mid=&#123;&#125;"</span>, mid); </span><br><span class="line"></span><br><span class="line">    recursion_mid(array, temp, low, mid, comp);</span><br><span class="line">    recursion_mid(array, temp, mid + <span class="number">1</span>, high, comp);</span><br><span class="line">    merge(array, temp, low, mid, high, comp);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Object[] array, Object[] temp, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high, Comparator comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(comp(array, mid + <span class="number">1</span>, mid, comp) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        LOGGER.debug(<span class="string">"mid=&#123;&#125; merge skipped..."</span>, mid); </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.arraycopy(array, low, temp, low, high - low + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = low, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = low; k &lt;= high; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(comp(temp, i, j, comp) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            array[k] = temp[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            array[k] = temp[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &gt; mid)&#123; </span><br><span class="line">            System.arraycopy(temp, j, array, k + <span class="number">1</span>, high - j + <span class="number">1</span>); <span class="comment">// skip left copy</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; high)&#123;</span><br><span class="line">            System.arraycopy(temp, i, array, k + <span class="number">1</span>, mid - i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.debug(<span class="string">"mid=&#123;&#125; merge &#123;&#125;"</span>, mid, Arrays.toString(array)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/20210506/20210506.3.jpg" alt=""></p>
<p>归并排序的缺点是在合并结果时，需要借助临时数组来整理顺序，然后再将临时数组中已排序序的元素拷贝回原数组，这就增加了空间复杂度，并且所需的额外内存空间与 N 成正比，但是它能保证：对于长度为 N 的任意数组进行排序，所需的比较次数最多为 $O(N\log_{2} {N}) $</p>
<ul>
<li><strong>证明：</strong> </li>
</ul>
<p>首先，对于任意长度为 $n$ 的数组，将其所需的比较次数（时间复杂度）记为：$T(n)$， 那么有：$T(n) = 0$， $n \leq 1$ </p>
<p>如果将长度 $n$ 的数组一分为二，则可以将其所需的比较次数表示为：$T(n) = 2 \times T(\frac{n}{2}) + C(n)$</p>
<p>$C(n)$ 表示两边子数组合并所需的比较次数，最差情况是两个数组中的元素交叉排列，比如 [2,4,6,8] 与 [1,3,5,7] 那么 $C(n) = n - 1$</p>
<p>下面将拆分次数记为：$k$</p>
<p>于是：$k = 1$，有：$T(n) = 2 \times T(\frac{n}{2}) + n - 1 $</p>
<p>对$\frac{n}{2}$继续拆分，即$k = 2$，则有：$T(n) = 2 \times (2 \times T(\frac{n}{4}) + \frac{n}{2} -1) + n - 1 = 4 \times T(\frac{n}{4}) + 2n - 1 - 2$</p>
<p>对$\frac{n}{4}$继续拆分，即$k = 3$，则有：$T(n) = 2 \times (2 \times (2 \times T(\frac{n}{8}) + n/4 - 1) + n/2 -1) + n - 1 = 8 \times T(\frac{n}{8}) + 3n - 1 - 2 - 4$</p>
<p><strong>…</strong>   </p>
<p>那么，在进行 $k$ 次拆分之后，则有：$T(n) = 2^k \times T(\frac{n}{2^k}) + kn - 1 - 2 - 4 -  … - 2^{k-1} = 2^k \times T(\frac{n}{2^k}) + kn + 1 - 2^k$</p>
<p>并且，如果最终在 $k$ 次拆分之后，子数组的元素个数都为 $1$，那么就有：$2^k = n$</p>
<p>故：$T(n) = n \times T(1) + n\log_{2} {n} + 1 - n = n\log_{2} {n} + 1 - n \in O(n\log_{2} {n})$ </p>
<p>类似的，在最好的情况下，每次合并操作只需要进行 $1$ 次比较，那么就有：$T(n) = 2^k \times T(\frac{n}{2^k}) + k = \log_{2} {n}$ </p>
<h4 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5. 快速排序"></a>5. 快速排序</h4><p>快速排序也是基于分治的一种实现，它选取一个切分元素 K，然后将数组分成左右两个子数组，并保证左子数组的所有元素都不大于 K，而又子数组的所有元素都不小于 K，这样如果左右子数组都分别有序，那么整个数组就是有序的，于是，对于左右子数组再以同样的方式递归进行排序就可以了。</p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/Echo/blob/master/src/main/java/io/github/echo/algorithms/sort/</span><span class="caption">Sorts.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort_quick</span><span class="params">(Object[] array, Comparator comp)</span> </span>&#123;</span><br><span class="line">    recursion_partition(array, <span class="number">0</span>, array.length - <span class="number">1</span>, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion_partition</span><span class="params">(Object[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high, Comparator comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> partition = partition(array, low, high, comp);</span><br><span class="line">    LOGGER.debug(<span class="string">" partition=&#123;&#125;"</span>, partition);</span><br><span class="line">    </span><br><span class="line">    recursion_partition(array, low, partition - <span class="number">1</span>, comp);</span><br><span class="line">    recursion_partition(array, partition + <span class="number">1</span>, high, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Object[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high, Comparator comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = high + <span class="number">1</span>; <span class="comment">// 左右扫描指针</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123; </span><br><span class="line">        <span class="keyword">while</span>(++i &lt; high &amp;&amp; comp(array, low, i, comp) &gt; <span class="number">0</span>)&#123;&#125;</span><br><span class="line">        <span class="keyword">while</span>(--j &gt; low &amp;&amp; comp(array, low, j, comp) &lt; <span class="number">0</span>)&#123;&#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(array, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low != j)&#123;</span><br><span class="line">        swap(array, low, j); <span class="comment">// 将切分元素交换到正确的位置 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/20210506/20210506.4.jpg" alt=""></p>
<p>快速排序与归并排序是互补的，它可以直接在原地排序，而不需要借助临时数组来进行整理和拷贝。但是<font color="#E51508">在归并排序中，每次都能将数组等分为两半，而在快速排序中，切分的位置则取决于数组的内容</font>。比如上面示例中的最后几趟，即如果数组原本是有序的状态，那么快速排序的复杂度反而会将为 $N^2$ 级别，因此快排的效率取决于切分元素的选择。</p>
<p>但是快速排序相对更加简洁，其在切分方法的内循环中只需用一个递增的索引将数组元素与一个定值进行比较，而在希尔排序和归并排序的内循环中，一般还要移动数据，所以它们一般都会比快速排序慢。</p>
<p>快速排序的最好情况是每次都能刚好将数组等分，这时它的比较次数可以类似于归并排序，因此有：$T(n) = 2T(\frac{n}{2}) + n$<br>于是复杂度 $\in O(N\log_{2} {N})$，而最差情况是 $\in N^2$。平均复杂度则约为 $1.39N\log_{2} {N}$，如果对数学有兴趣的话，可以尝试证明一下</p>
<ul>
<li><strong>改进</strong></li>
</ul>
<p><br><strong>参考：</strong></p>
<ol>
<li>《算法》</li>
<li><a href="https://zhuanlan.zhihu.com/p/341225128" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/341225128</a></li>
<li><a href="https://www.cnblogs.com/zhyantao/p/10424874.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhyantao/p/10424874.html</a></li>
<li><a href="https://www.jianshu.com/p/e74eb43960a1" target="_blank" rel="noopener">https://www.jianshu.com/p/e74eb43960a1</a></li>
</ol>

      
    </div>
	
    <footer>
      
	  
	    
	<nav id="pagination">
	  
	  
	  
		  <a class="alignright next" href="/2020/06/01/20200601/">
		    《UNIX环境高级编程》 文件
		  </a>
	  
	  <div class="clearfix"></div>
	</nav>
	
	    
        
  
  <div class="categories">
    <a href="/categories/算法设计/">算法设计</a>
  </div>


        

         		        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'd7beb7890a79c73a3e3d',
        clientSecret: '80ea1fc195ae4b80cbd65ec9f1ce68d59595af4b',
        id: md5(window.location.pathname),
        repo: 'shanhm1991.github.io',
        owner: 'shanhm1991',
        admin: 'shanhm1991'
    })
    gitalk.render('gitalk-container')
</script>                              



</div></div>
    <aside id="sidebar" class="alignright">
  


  

  

  

  
<div class="widget catlog">
<h3 class="title">Catlog</h3>
<ul class="entry_catlog">
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#引言"><span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-选择排序-冒泡排序"><span class="toc-text">1. 选择排序&#x2F;冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-插入排序"><span class="toc-text">2. 插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-希尔排序"><span class="toc-text">3. 希尔排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-归并排序"><span class="toc-text">4. 归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-快速排序"><span class="toc-text">5. 快速排序</span></a></li></ol></li></ol>
</div>




</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">

  
  
      &copy; 2021 shanhm1991 
  
  
  
  <font style="float: right">
</div>
<div class="clearfix"></div>
</footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
