<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>java容器Api. TreeMap以及Set | Essay</title>
  <meta name="author" content="shanhm1991">
  
  <meta name="description" content="引言1. 概述前面HashMap中只是用红黑树来作为散列表中发生冲突时降低节点遍历深度的一个手段，而TreeMap则完全是对红黑树的一个直接应用，
因此它是有序的且查找深度不超过2lg(N+1)。前面LinkedHashMap中的有序是指插入的先后顺序，与List一样，而TreeMap是大小比较关系上的有序。
其实关于红黑树之前都说过了，也利用红黑树实现了一个可以存放重复key的MultiRBTreeMap，可以看成TreeMap的扩展，只是没有完善所有接口，
想法就是在红黑树的基础上再维护一个链表结构，具体可以见：数据结构. 红黑树     
至于Set的各种实现，比较简单，就是依赖其对应的Map，将存在的元素作为Map的keySet，用一个简单对象作为统一的value，这样就将具体的操作和实现都委托给了Map。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="java容器Api. TreeMap以及Set"/>
  <meta property="og:site_name" content="Essay"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Essay" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-147251181-1', 'auto');
	ga('send', 'pageview');

</script>


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header id="header" class="inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="alignleft">
  <h1><a href="/">Essay</a></h1>
  <h2><font style="color: #999;">articles:  42 &nbsp;&nbsp;&nbsp; views: <span id="busuanzi_value_site_uv"></span></font></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/about">Abount</a></li>
    
      <li><a href="/books">Books</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>

<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-20190703" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2019-07-02T16:00:00.000Z"><a href="/2019/07/03/20190703/">2019-07-03</a></time>
	  
      
  
    <h1 class="p-name title" itemprop="headline name">java容器Api. TreeMap以及Set</h1>
	<div class="title" style="padding: 5px 0px 20px 10px; color: #766;">———— jdk 1.8</div> 
  

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<font style="color: #999;">words: 1.5k &nbsp;&nbsp;&nbsp; views: <span id="busuanzi_value_page_pv"></span></font>

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>前面<code>HashMap</code>中只是用红黑树来作为散列表中发生冲突时降低节点遍历深度的一个手段，而<code>TreeMap</code>则完全是对红黑树的一个直接应用，
因此它是有序的且查找深度不超过2lg(N+1)。前面<code>LinkedHashMap</code>中的有序是指插入的先后顺序，与<code>List</code>一样，而<code>TreeMap</code>是大小比较关系上的有序。
其实关于红黑树之前都说过了，也利用红黑树实现了一个可以存放重复key的<code>MultiRBTreeMap</code>，可以看成<code>TreeMap</code>的扩展，只是没有完善所有接口，
想法就是在红黑树的基础上再维护一个链表结构，具体可以见：<a href="https://shanhm1991.github.io/2019/06/10/20190610/">数据结构. 红黑树</a>     </p>
<p>至于<code>Set</code>的各种实现，比较简单，就是依赖其对应的<code>Map</code>，将存在的元素作为Map的keySet，用一个简单对象作为统一的value，这样就将具体的操作和实现都委托给了Map。</p>
<a id="more"></a>

<h3 id="2-TreeMap"><a href="#2-TreeMap" class="headerlink" title="2. TreeMap"></a>2. TreeMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-属性"><a href="#2-1-属性" class="headerlink" title="2.1. 属性"></a>2.1. 属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较器，可以在构造器中指定比较的行为</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树根节点，HashMap中没有红黑树没有记录root节点，而是为节点提供了一个root()方法，</span></span><br><span class="line"><span class="comment">//因为HashMap是从一个红黑树节点出发的，而TreeMap是从红黑树本身出发的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素总数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录修改次数，阻止并发修改</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-接口实现"><a href="#2-2-接口实现" class="headerlink" title="2.2. 接口实现"></a>2.2. 接口实现</h4><p>基本的Map接口实现都差不多，区别在于TreeMap的元素是排过序的，因此它可以做更多的事情。</p>
<h5 id="2-2-1-lowerEntry-higherEntry"><a href="#2-2-1-lowerEntry-higherEntry" class="headerlink" title="2.2.1. lowerEntry/higherEntry"></a>2.2.1. lowerEntry/higherEntry</h5><p>比如获取与给定key相邻且大于或者小于的元素，在此基础上就可以实现<code>subMap</code>了，即通过指定起止节点从TreeMap中获取特定区间的元素。<br><font color="green">对于<code>getLowerEntry</code>，如果给定的<code>key</code>大于<code>p.key</code>，那么继续向右子树比较，否则尝试向左子树比较，如果这时没有左子树，
那么可以回过头向上寻找p的第一个左父节点p-left-parent，即p是p-left-parent的右子树的最小节点，因此可以断定<code>p-left-parent &lt; p</code>，而且是相邻的。
而且，由于遍历过程都是自上而下的，那么<code>key</code>肯定是先与p-left-parent比较过的，并且p-left-parent.key &lt; key，现在又有key &lt;= p.key，因此，p-left-parent
就是相邻且小于key的节点了。</font>对于<code>getHigherEntry</code>也是同样的思路。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lowerEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getLowerEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">higherEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getHigherEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; Map.<span class="function">Entry&lt;K,V&gt; <span class="title">exportEntry</span><span class="params">(TreeMap.Entry&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">        <span class="keyword">new</span> AbstractMap.SimpleImmutableEntry&lt;&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getLowerEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(key, p.key);</span><br><span class="line">        <span class="comment">//如果key &gt; p.key</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果p.right不为空，继续与右子树比较，否则p已经是相邻且小于key的节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//如果key &lt;= p.key</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果p.left不为空，尝试与左子树比较，否则向上寻找p的第一个左父节点parent</span></span><br><span class="line">            <span class="comment">//那么parent.key肯定小于p.key，并且相邻。又因为是自上向下遍历的，那么肯定parent.key &lt; key &lt;= p.key</span></span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; parent = p.parent;</span><br><span class="line">                Entry&lt;K,V&gt; ch = p;</span><br><span class="line">                <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.left) &#123;</span><br><span class="line">                    ch = parent;</span><br><span class="line">                    parent = parent.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getHigherEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(key, p.key);</span><br><span class="line">        <span class="comment">//如果key &lt; p.key</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果p.left不为空，继续与左子树比较，否则p已经是相邻且大于key的节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//如果key &gt;= p.key</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果p.right不为空，尝试与右子树比较，否则向上寻找p的第一个右父节点parent</span></span><br><span class="line">            <span class="comment">//那么parent.key肯定大于p.key，并且相邻。又因为是自上向下遍历的，那么肯定parent.key &gt; key &gt;= p.key</span></span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; parent = p.parent;</span><br><span class="line">                Entry&lt;K,V&gt; ch = p;</span><br><span class="line">                <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.right) &#123;</span><br><span class="line">                    ch = parent;</span><br><span class="line">                    parent = parent.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-successor-predecessor"><a href="#2-2-2-successor-predecessor" class="headerlink" title="2.2.2. successor/predecessor"></a>2.2.2. successor/predecessor</h5><p>这两个并不是接口实现，但它们是实现迭代器的基础。之前在实现<code>MultiRBTreeMap</code>时是借助的链表，这里可以看看TreeMap中的实现：
对于<code>successor</code>，如果node有右子树，那么直接取右子树的最左节点；否则向上寻找第一个右父节点parent。对于<code>predecessor</code>也是类似的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//取右子树最小节点，即大于且最靠近node的节点</span></span><br><span class="line">		Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">		<span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">			p = p.left;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">		Entry&lt;K,V&gt; ch = t;</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">			ch = p;</span><br><span class="line">			p = p.parent;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">Entry&lt;K,V&gt; <span class="title">predecessor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (t.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Entry&lt;K,V&gt; p = t.left;</span><br><span class="line">		<span class="keyword">while</span> (p.right != <span class="keyword">null</span>)</span><br><span class="line">			p = p.right;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">		Entry&lt;K,V&gt; ch = t;</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.left) &#123;</span><br><span class="line">			ch = p;</span><br><span class="line">			p = p.parent;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-HashSet-LinkedHashSet-TreeSet"><a href="#3-HashSet-LinkedHashSet-TreeSet" class="headerlink" title="3. HashSet/LinkedHashSet/TreeSet"></a>3. HashSet/LinkedHashSet/TreeSet</h3><p>将几个Set放在一起说是因为它们都是一样的套路，即将接口的操作委托给对应的Map，能说的内容也很有限，可以多体会作者的这种设计，
比如让Map借助返回的Set实例来实现Iterator迭代，又让Set依赖一个Map实例而实现自身。</p>

      
    </div>
	
	
	
    <footer>
      
	  
	    
	<nav id="pagination">
	  
	  
	  
		  <a class="alignright next" href="/2019/07/02/20190702/">
		    java容器Api. HashMap与LinkedHashMap
		  </a>
	  
	  <div class="clearfix"></div>
	</nav>
	
	    
        
  
  <div class="categories">
    <a href="/categories/java源码/">java源码</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/TreeMap/">TreeMap</a>, <a href="/tags/Set/">Set</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'd7beb7890a79c73a3e3d',
        clientSecret: '80ea1fc195ae4b80cbd65ec9f1ce68d59595af4b',
        id: md5(window.location.pathname),
        repo: 'shanhm1991.github.io',
        owner: 'shanhm1991',
        admin: 'shanhm1991'
    })
    gitalk.render('gitalk-container')
</script>                              



</div></div>
    <aside id="sidebar" class="alignright">
  


  

  

  

  
<div class="widget catlog">
<h3 class="title">Catlog</h3>
<ul class="entry_catlog">
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-概述"><span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-TreeMap"><span class="toc-text">2. TreeMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-属性"><span class="toc-text">2.1. 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-接口实现"><span class="toc-text">2.2. 接口实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-lowerEntry-higherEntry"><span class="toc-text">2.2.1. lowerEntry&#x2F;higherEntry</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-2-successor-predecessor"><span class="toc-text">2.2.2. successor&#x2F;predecessor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-HashSet-LinkedHashSet-TreeSet"><span class="toc-text">3. HashSet&#x2F;LinkedHashSet&#x2F;TreeSet</span></a></li></ol></li></ol>
</div>




</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2020 shanhm1991 
  
  <font style="float: right">
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
