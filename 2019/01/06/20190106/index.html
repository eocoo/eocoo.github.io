<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>java并发编程实战.笔记六（任务的取消与关闭） | Essay</title>
  <meta name="author" content="shanhm1991">
  
  <meta name="description" content="引言如果外部代码能在某个操作正常完成之前将其置入完成状态，那么这个操作就可以称为可取消的，行为良好的软件都应该能很完善地处理失败、关闭和取消等过程。    

一个可取消的任务必须拥有取消策略，在这个策略中定义：


其他代码如何请求取消该任务；
任务在何时检查是否已经请求了取消；
在响应取消请求时应该执行哪些操作；

Java中并没有提供任何机制来安全地终止线程，但它提供了一种协作机制。通过设置某个已请求取消的标志，然后任务执行过程中定期地查看该标志，如果设置了，那么任务提前结束。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="java并发编程实战.笔记六（任务的取消与关闭）"/>
  <meta property="og:site_name" content="Essay"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Essay" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-147251181-1', 'auto');
	ga('send', 'pageview');

</script>


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header id="header" class="inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="alignleft">
  <h1><a href="/">Essay</a></h1>
  <h2><font style="color: #999;">articles:  44 &nbsp;&nbsp;&nbsp; views: <span id="busuanzi_value_site_uv"></span></font></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/about">Abount</a></li>
    
      <li><a href="/books">Books</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>

<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-20190106" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2019-01-05T16:00:00.000Z"><a href="/2019/01/06/20190106/">2019-01-06</a></time>
	  
      
  
    <h1 class="p-name title" itemprop="headline name">java并发编程实战.笔记六（任务的取消与关闭）</h1>
	
  

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<font style="color: #999;">words: 8.4k &nbsp;&nbsp;&nbsp; views: <span id="busuanzi_value_page_pv"></span></font>

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>如果外部代码能在某个操作正常完成之前将其置入完成状态，那么这个操作就可以称为可取消的，<font color="red">行为良好的软件都应该能很完善地处理失败、关闭和取消等过程。</font>    </p>
<ul>
<li>一个可取消的任务必须拥有取消策略，在这个策略中定义：</li>
</ul>
<ol>
<li>其他代码如何请求取消该任务；</li>
<li>任务在何时检查是否已经请求了取消；</li>
<li>在响应取消请求时应该执行哪些操作；</li>
</ol>
<p><font color="LimeGreen">Java中并没有提供任何机制来安全地终止线程，但它提供了一种协作机制。通过设置某个已请求取消的标志，然后任务执行过程中定期地查看该标志，如果设置了，那么任务提前结束。</font></p>
<a id="more"></a>

<h3 id="1-自定义取消机制"><a href="#1-自定义取消机制" class="headerlink" title="1. 自定义取消机制"></a>1. 自定义取消机制</h3><h4 id="1-1-示例：可取消的素数生成器"><a href="#1-1-示例：可取消的素数生成器" class="headerlink" title="1.1. 示例：可取消的素数生成器"></a>1.1. 示例：可取消的素数生成器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeGenerator</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BigInteger&gt; primes = <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BigInteger p = BigInteger.ONE;</span><br><span class="line">        <span class="keyword">while</span>(!cancelled)&#123;</span><br><span class="line">            p = p.nextProbablePrime();</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                primes.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cancelled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;BigInteger&gt; <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(primes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PrimeGenerator</code>使用一种简单的取消策略：设定一个取消标志，如果被置位了，则说明收到了取消请求。它在每次搜索素数前首先检查是否存在取消请求，如果存在则取消。<br>因此，客户端可以通过调用<code>cancel</code>来请求取消，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;BigInteger&gt; <span class="title">secondPrimes</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    PrimeGenerator generator = <span class="keyword">new</span> PrimeGenerator();</span><br><span class="line">    <span class="keyword">new</span> Thread(generator).start();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">//确保即使在调用sleep时被中断也能取消素数生成器的执行</span></span><br><span class="line">        generator.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> generator.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PrimeGenerator</code>的取消机制最终会使得素数生成器的任务退出，但在退出的过程中需要花费一定的时间。比如上面的代码使用中通常并不会刚好在运行1秒钟后停止，因为在请求取消的时刻和<code>run</code>方法中循环执行下一次检查之间存在延迟。</p>
<p><font color="red">更严重的，如果使用这种方法的任务调用了一个阻塞方法，那么任务可能永远不会检查取消标志，因此永远不会结束。</font></p>
<ul>
<li>例如：<code>BlockingQueue.put</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BrokenPrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    BrokenPrimeProducer(BlockingQueue&lt;BigInteger&gt; queue)&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            BigInteger p = BigInteger.ONE;</span><br><span class="line">            <span class="keyword">while</span>(!cancelled)&#123;</span><br><span class="line">                queue.put(p = p.nextProbablePrime());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cancelled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果生产者的速度超过了消费者的处理速度，队列将被填满，<code>put</code>方法将会阻塞。试想当生产者在<code>put</code>方法上阻塞时，如果消费者停止消费并希望取消生产者任务，它会调用<code>cancel()</code>方法来设置<code>cancelled</code>标志。但此时生产者却永远不能检查这个标志，
因为它无法从阻塞的<code>put</code>方法中恢复过来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumePrimes</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    BlockingQueue&lt;BigInteger&gt; primes = <span class="keyword">new</span> LinkedBlockingQueue&lt;BigInteger&gt;();</span><br><span class="line">    BrokenPrimeProducer producer = <span class="keyword">new</span> BrokenPrimeProducer(primes);</span><br><span class="line">    producer.start();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(needMorePrimes())&#123;</span><br><span class="line">            consume(primes.take());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">//如果阻塞，将取消失败</span></span><br><span class="line">        producer.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-中断"><a href="#2-中断" class="headerlink" title="2. 中断"></a>2. 中断</h3><p><font color="LimeGreen">每个线程中都有一个boolean类型的中断状态。当中断线程时，其中断状态将被设置为ture。</font><br>在Thread中提供了中断线程以及查询线程中断状态的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>interrupt</code>中断目标线程</li>
<li><code>isInterrupted</code>返回目标线程的中断状态</li>
<li><code>interrupted</code>清除当前线程的中断状态，并返回它之前的值，也是清除中断状态的唯一方法。</li>
</ul>
<p>在使用<code>interrupted</code>时要小心，因为它会清除当前线程的中断状态。如果在调用时返回了<code>true</code>，说明收到过中断请求，所以除非你想屏蔽这个中断，否则必须对它进行处理：可以抛出<code>InterruptedException</code>，
或者再次调用<code>interrupt</code>来恢复中断状态<font color="Gray">（这样还可以保留中断请求，并在之后的某个时候进行检查和处理）。</font></p>
<p>当线程在非阻塞状态下中断时，它的中断状态将被设置，然后由具体的线程任务来决定是否检查以及如何处理<font color="Gray">（所以如果任务不进行检查处理，那中断状态设置也只是设置而已）。</font><font color="red">因此中断并不会真正的中断一个正在运行的线程，
而只是发出中断请求，然后由线程在下一个合适的时机做出中断响应。</font></p>
<p><code>Thread</code>中常见的阻塞方法，如<code>Thread.sleep</code>和<code>Object.wait</code>等，都会检查线程何时中断，并且在发现中断时提前返回。它们在响应中断时执行的操作包括：清除中断状态，抛出<code>InterruptedException</code>，表示阻塞操作由于中断而提前结束。</p>
<h4 id="2-1-示例改进：使用中断实现取消"><a href="#2-1-示例改进：使用中断实现取消" class="headerlink" title="2.1. 示例改进：使用中断实现取消"></a>2.1. 示例改进：使用中断实现取消</h4><p>如果任务能够响应中断，那么可以使用中断作为取消机制，并且可以利用许多类库中提供的中断支持。上面<code>BrokenPrimeProducer</code>说明了一些自定义的取消机制无法与可阻塞的库函数实现良好的交互，但如果使用中断而不是<code>boolean</code>标志来实现取消，
可以很容易解决。<br>通常中断是实现取消的最合理方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line">    </span><br><span class="line">    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue)&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            BigInteger p = BigInteger.ONE;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                queue.put(p = p.nextProbablePrime());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="comment">//直接退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中有两个位置可以检测出中断：在阻塞的<code>put</code>方法中，以及在循环开始处。由于调用了阻塞的<code>put</code>方法，因此可以不进行显示的检测，因为<code>put</code>中会检测并响应中断，并抛出<code>InterruptedException</code>使任务退出。
但在循环开始处执行检测会提高对中断的响应性，即如果可阻塞的方法的调用频率并不高，则不足以获得足够的响应性。</p>
<h4 id="2-2-关于中断策略"><a href="#2-2-关于中断策略" class="headerlink" title="2.2. 关于中断策略"></a>2.2. 关于中断策略</h4><p>最合理的中断策略是某种形式的线程级取消操作或服务级取消操作：尽快退出，在必要时进行清理，通知某个所有者该线程已经退出。</p>
<p><font color="red">一个中断请求可能有一个或多个接收者，比如中断线程池中的某个工作者线程，意味着取消当前任务，同时也意味着关闭工作者线程。区分任务和线程对中断的响应是很重要的，任务不会在其自己拥有的线程中执行，
而是在某个服务拥有的线程中执行。</font>对于非线程所有者的代码来说（例如，对于线程池而言，任何在线程池实现以外的代码），应该小心的保存中断状态，这样拥有线程的代码才能对中断做出响应。（当你为一户人家打扫房屋时，即使主人不在家，
也不应该把在这段时间内收到的邮件扔掉，而应该把邮件收起来，等主人回来一户再交给他们处理，尽管你可以阅读他们）。</p>
<p><font color="Gray">理解上面这段话很重要，我们知道线程就是系统提供的一个执行上下文，java中提供了一些对象帮我们管理线程并代理对它的操作，比如Thread.start()就是开启一个执行上下文，这些对象就是线程的拥有者，也就是上面所说的拥有线程的代码。
如果我们要执行一段业务逻辑，就将这段逻辑封装成一个任务并委托给这些对象去挂到线程执行，当任务结束时线程便结束，而这里的业务逻辑或者任务就是上面所说的非线程所有者的代码。如果我们希望线程能够复用，可以在线程执行完一个任务后将它挂起，
并等待下一个任务。同样，java也提供了线程池ThreadPoolExecutor来替我们做了这件事，因此线程池也是线程的拥有者。</font></p>
<p><br><font color="Gray">很多时候我们写的任务逻辑是服务业务流程中的某一段，因此对于我们的代码而言，服务便是拥有线程的代码。试想如果现在服务关闭，那么它会向所有的工作线程发送中断请求。
假设一个设计用来复用的工作线程刚好在执行我们任务的过程中收到了中断请求，而我们在任务中的处理是忽略或丢弃中断，那么在执行完任务后线程的拥有者代码也不知道收到过中断请求，将继续挂起等待任务，即便它本意对中断的处理是释放线程。
线程池的设计当然考虑到了这点，它定义和维护了一套自己的状态，并在很多节点进行检查，比如在每次addWorker时。总之，即便我们不想在任务中处理中断，至少也应该恢复中断状态或者说保留中断请求。</font></p>
<p>这就是为什么大多数可阻塞的库函数都只是抛出<code>InterruptedException</code>作为中断响应。因为它们永远不会在某个由自己拥有的线程中执行，因此它们为任务或者库代码实现了最合理的取消策略：尽快退出执行流程，并把中断信息传递给调用者，
从而使调用栈上的上层代码可以采取进一步的操作。</p>
<p>因此，任务不应该对执行任务的线程的中断策略做出任何假设，因为每个线程拥有各自的中断策略，除非你知道中断对该线程的含义，否则就不应该中断这个线程。</p>
<h4 id="2-3-关于中断响应"><a href="#2-3-关于中断响应" class="headerlink" title="2.3. 关于中断响应"></a>2.3. 关于中断响应</h4><ul>
<li>有两种策略可用于处理<code>InterruptedException</code></li>
</ul>
<ol>
<li>传递异常。从而使你的方法也成为可中断的阻塞方法。</li>
<li>恢复中断状态，从而使调用栈中的上层代码能够对其进行处理。</li>
</ol>
<p>如果不想或无法传递<code>InterruptedException</code>(或许任务是通过<code>Runnable</code>来定义的)，那么需要寻找另一种方式来保存中断请求。一种标准的方法就是通过再次调用<code>interrupt</code>来恢复中断状态。你不能屏蔽<code>InterruptedException</code>，
例如在<code>catch</code>块中捕获到异常却不做任何处理，除非你在代码中实现了线程的中断策略。虽然上面示例中<code>PrimeGenerator</code>屏蔽了中断，那是因为它已经知道线程将要结束，在调用栈中已经没有上层代码需要知道中断信息。
但大多数代码并不知道它们将在哪个线程中运行，因此应该保存中断状态。</p>
<p>对于一些不支持取消但仍可以调用可中断阻塞方法的操作，它们必须在循环中调用这些方法，并在发现中断后重新尝试。在这种情况下，它们应该在本地保存中断状态，并在返回前恢复而不是捕获<code>InterruptedException</code>时恢复状态。
如果过早地设置中断状态，就可能引起无限循环，因为大多数可中断的阻塞方法都会在入口处检查中断状态，并且当发现该状态已被设置时会立即抛出<code>InterruptedException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目的就是不处理中断，也不忽略中断，而是把中断状态保留下来</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">getNextTask</span><span class="params">(BlockingQueue&lt;Taskgt&gt; queue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> queue.take();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(interrupted)&#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时在取消过程中可能还涉及除了中断状态之外的其他状态，中断可以用来获得线程的注意，并且由中断线程保存的信息，可以为中断的线程提供进一步的指示（当访问这些信息时，要确保使用了同步）。例如，
当一个由<code>ThreadPoolExecutor</code>拥有的工作者线程检测到中断时，它会检查线程池是否正在关闭。如果是，它会在结束之前执行一些线程池清理工作，否则它可能创建一个新线程将线程池恢复到合理的规模<font color="Gray">（联系前面说的，
如果任务中把中断吃掉了，那么工作者线程就无法检测到中断，当然线程池有其他的办法来解决，以后会整理介绍线程池的api）</font>。</p>
<h3 id="3-示例：任务计时运行"><a href="#3-示例：任务计时运行" class="headerlink" title="3. 示例：任务计时运行"></a>3. 示例：任务计时运行</h3><p>需求：将给定的任务执行指定的时间，并纪录下异常信息</p>
<h4 id="3-1-在外部线程中安排中断"><a href="#3-1-在外部线程中安排中断" class="headerlink" title="3.1. 在外部线程中安排中断"></a>3.1. 在外部线程中安排中断</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService cancelExec = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(Runnable r,<span class="keyword">long</span> timeout,TimeUnit unit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread taskThread = Thread.currentThread();</span><br><span class="line">    cancelExec.schedule(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            taskThread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,timeout,unit);</span><br><span class="line">    </span><br><span class="line">    r.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>timedRun</code>可以在任意一个线程中调用，因此它无法知道这个调用线程的中断策略。如果线程不响应中断，那么<code>timedRun</code>只能在任务结束时才返回，此时可能已经超过了指定的时限。而如果任务在超时之前完成，
那么中断<code>timedRun</code>所在线程的请求将在<code>timedRun</code>返回到调用者之后处理，虽然不知道那时情况下将运行什么代码，但结果一定是不好的。</p>
<h4 id="3-2-改进：在专门的线程中中断任务"><a href="#3-2-改进：在专门的线程中中断任务" class="headerlink" title="3.2. 改进：在专门的线程中中断任务"></a>3.2. 改进：在专门的线程中中断任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService cancelExec = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(Runnable r,<span class="keyword">long</span> timeout,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">RethrowableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">volatile</span> Throwable t;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Throwable t)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.t = t;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">rethrow</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(t != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> launderThrowable(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RethrowableTask task = <span class="keyword">new</span> RethrowableTask();</span><br><span class="line">        <span class="keyword">final</span> Thread taskThread = <span class="keyword">new</span> Thread(task);</span><br><span class="line">        taskThread.start();</span><br><span class="line">        </span><br><span class="line">        cancelExec.schedule(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                taskThread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, timeout, unit);</span><br><span class="line">        taskThread.join(unit.toMillis(timeout)); </span><br><span class="line">        task.rethrow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在启动任务线程后，<code>timedRun</code>将执行一个限时的<code>join</code>方法，同步等待这个线程结束或者超时。在<code>join</code>返回后，它将检查任务是否有异常抛出。如果有的话，则在调用<code>timedRun</code>的线程中再次抛出。自定义执行任务的线程拥有自己的执行策略，
即使任务不响应中断，限时运行的方法仍能返回到它的调用者<font color="Gray">（但如果任务本身不响应中断，它将继续运行下去，所以也只能是保证了这个方法能限时返回，并不代表任务能限时结束）。</font>而且由于依赖于限时<code>join</code>，
你也无法知道任务是正常结束了还是join超时返回。</p>
<h4 id="3-3-改进：通过Future来实现取消"><a href="#3-3-改进：通过Future来实现取消" class="headerlink" title="3.3. 改进：通过Future来实现取消"></a>3.3. 改进：通过Future来实现取消</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(Runnable r,<span class="keyword">long</span> timeout,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Future&lt;?&gt; task = taskExec.submit(r);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            task.get();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(TimeoutException e)&#123;</span><br><span class="line">            <span class="comment">//取消任务</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">            <span class="comment">//如果任务中抛出了异常，那么重新抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//如果任务已经结束，那么执行取消操作也不会带来任何影响</span></span><br><span class="line">            <span class="comment">//如果任务正在运行，那么将被中断</span></span><br><span class="line">            task.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ExecutorService.submit</code>将返回一个<code>Future</code>来描述任务的状态。<code>Future</code>拥有一个<code>cancel</code>方法，带有一个<code>boolean</code>类型参数。如果设为<code>true</code>并且当前任务正在某个线程中运行，那么会请求中断这个线程。
如果设置为<code>false</code>，意味着，如果任务还没启动，就不要启动它。</p>
<h3 id="4-解决不可中断的阻塞问题"><a href="#4-解决不可中断的阻塞问题" class="headerlink" title="4. 解决不可中断的阻塞问题"></a>4. 解决不可中断的阻塞问题</h3><p><font color="red">并非所有的可阻塞方法或阻塞机制都能响应中断，对于这些由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，但这要求必须指定线程阻塞的原因。</font></p>
<ul>
<li><p><strong>Java.io包中的同步Socket</strong> I/O 在服务器应用程序中，最常见的阻塞I/O形式就是对套接字进行读取和写入。虽然<code>InputStream</code>和<code>OutputStream</code>中的<code>read</code>和<code>write</code>等方法都不会响应中断，但通过关闭底层的套接字，
可以使得由于执行<code>read</code>或<code>write</code>等方法而被阻塞的线程抛出一个<code>SocketException</code>。</p>
</li>
<li><p><strong>Java.io包中的同步I/O</strong> 当中断一个正在<code>InterruptibleChannel</code>上等待的线程时，将抛出<code>ClosedByInterruptException</code>并关闭链路（这会使得其他在这条链路上阻塞的线程同样抛出<code>ClosedByInterruptException</code>）。
当关闭一个<code>InterruptibleChannel</code>时，将导致所有在链路上阻塞的线程都抛出<code>AsynchronousCloseException</code>。</p>
</li>
<li><p><strong>selector的异步I/O</strong> 如果一个线程在调用<code>Selector.select</code>方法使阻塞了，那么调用<code>close</code>或<code>wakeup</code>方法会使线程抛出<code>ClosedSelectorException</code>并提前返回。</p>
</li>
<li><p><strong>获取某个锁</strong> 如果一个线程由于等待某个内置锁而阻塞，那么将无法响应中断，不会理会中断请求。但在Lock类中提供了<code>lockInterruptibly</code>方法。该方法允许在等待一个锁的同时仍能响应中断。</p>
</li>
</ul>
<h4 id="4-1-改写interrupt将非标准的取消封装在Thread中"><a href="#4-1-改写interrupt将非标准的取消封装在Thread中" class="headerlink" title="4.1. 改写interrupt将非标准的取消封装在Thread中"></a>4.1. 改写interrupt将非标准的取消封装在Thread中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InputStream in;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReaderThread</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.in = socket.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> count = in.read(buf);</span><br><span class="line">                <span class="keyword">if</span>(count &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    processBuffer(buf,count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ReaderThread</code>管理了一个套接字连接，采用同步方式从该套接字中读取数据，并将接收到的数据传递给<code>processBuffer</code>。为了结束某个用户的连接或者关闭服务器，<code>ReaderThread</code>改写了<code>interrupt</code>方法，使其既能处理标准的中断，也能关闭底层的套接字。</p>
<h4 id="4-2-改写newTaskFor将非标准的取消封装在任务中"><a href="#4-2-改写newTaskFor将非标准的取消封装在任务中" class="headerlink" title="4.2. 改写newTaskFor将非标准的取消封装在任务中"></a>4.2. 改写newTaskFor将非标准的取消封装在任务中</h4><ol>
<li>定义<code>CancellableTask</code>接口扩展<code>Callable</code>，并增加一个<code>cancel</code>方法和一个<code>newTask</code>工厂方法来构造<code>RunnableFuture</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CancellableTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTask</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>定义<code>CancellingExecutor</code>扩展<code>ThreadPoolExecutor</code>，通过改写<code>newTaskFor</code>使得<code>CancellableTask</code>可以自定义自己的<code>Future</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancellingExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CancellingExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span>&lt;T&gt; RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(callable <span class="keyword">instanceof</span> CancellableTask)&#123;</span><br><span class="line">            <span class="keyword">return</span> ((CancellableTask&lt;T&gt;)callable).newTask();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.newTaskFor(callable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>定义<code>SocketUsingTask</code>实现<code>CancellableTask</code>，在<code>cancel</code>中关闭套接字，并在<code>newTask</code>返回的<code>RunnableFuture</code>中重写<code>Future</code>的<code>cancel</code>方法。
因此，如果<code>SocketUsingTask</code>通过其自己的<code>Future</code>来取消，那么底层的套接字将被关闭并且线程将被中断。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketUsingTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CancellableTask</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSocket</span><span class="params">(Socket s)</span></span>&#123;</span><br><span class="line">        socket = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RunnableFuture&lt;T&gt; <span class="title">newTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    SocketUsingTask.<span class="keyword">this</span>.cancel();</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.cancel(mayInterruptIfRunning);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="5-停止基于线程的服务问题"><a href="#5-停止基于线程的服务问题" class="headerlink" title="5. 停止基于线程的服务问题"></a>5. 停止基于线程的服务问题</h3><p>应用程序通常会拥有多个线程服务，如线程池，并且这些服务的生命周期通常比创建它们的方法的生命周期更长。如果应用程序准备退出，那么这些服务所拥有的线程也需要结束，以便使jvm正常退出。<br>与其他封装对象一样，线程的所有权是不可传递的：应用程序可以拥有服务，服务也可以拥有工作者线程，但应用程序并不能拥有工作者线程。因此应用程序不能直接停止工作者线程，相反，服务应该提供生命周期方法来关闭它自己以及它所拥有的线程。
这样，当应用程序关闭该服务时，服务就可以关闭所有的线程了。比如在<code>ExecutorService</code>中提供了<code>shutdown</code>和<code>shutdownNow</code>等方法。</p>
<h3 id="6-示例：日志服务的停止"><a href="#6-示例：日志服务的停止" class="headerlink" title="6. 示例：日志服务的停止"></a>6. 示例：日志服务的停止</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogWriter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoggerThread logger;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogWriter</span><span class="params">(PrintWriter writer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">        <span class="keyword">this</span>.logger = <span class="keyword">new</span> LoggerThread(writer);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        logger.start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        queue.put(msg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> PrintWriter writer;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LoggerThread</span><span class="params">(PrintWriter writer)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.writer = writer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    writer.println(queue.take());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line"> </span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;    </span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LogWriter</code>给出了一个简单的日志服务示例，产生日志消息的线程是由<code>LogWriter</code>通过<code>BlockingQueue</code>将消息提交给日志线程，并由日志线程写入。要停止日志线程很容易，因为它调用的<code>take</code>能响应中断，因此只需中断日志线程就能停止服务。</p>
<p>但是，这种直接关闭的做法会丢失那些正在等待写入到日志的信息，而且其他线程将在调用log时被阻塞，
因为日志消息队列是满的。<font color="red">因此当取消一个生产者–消费者操作时，需要同时取消生产者和消费者。</font>而示例中由于生产者并不是专门的线程，因此要取消将非常困难。</p>
<h4 id="6-1-改进：设置关闭标志"><a href="#6-1-改进：设置关闭标志" class="headerlink" title="6.1. 改进：设置关闭标志"></a>6.1. 改进：设置关闭标志</h4><p>可以设置某个已请求关闭标志，以避免进一步提交日志，并在收到关闭请求后，消费者将队列中的所有消息写入日志，并解除所有在调用log时阻塞的生产者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogWriter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoggerThread logger;</span><br><span class="line">    <span class="keyword">private</span> PrintWriter writer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isShutdown;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> reservations;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogWriter</span><span class="params">(PrintWriter writer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">        <span class="keyword">this</span>.logger = <span class="keyword">new</span> LoggerThread();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        logger.start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            isShutdown = <span class="keyword">true</span>;</span><br><span class="line">            logger.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isShutdown)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ++reservations;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.put(msg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="keyword">synchronized</span>(LogWriter.<span class="keyword">this</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(isShutdown &amp;&amp; reservations == <span class="number">0</span>)&#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        String msg = queue.take();</span><br><span class="line">                        <span class="keyword">synchronized</span>(LogWriter.<span class="keyword">this</span>)&#123;</span><br><span class="line">                            --reservations;</span><br><span class="line">                        &#125;</span><br><span class="line">                        writer.println(msg);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line"> </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为<code>LogWriter</code>提供可靠的关闭操作需要解决竞态条件问题，因而要使日志消息的提交操作成为原子操作。但是，并不希望在消息加入队列时去持有一个锁，因为<code>put</code>方法本身就可以阻塞。可以通过原子方式来检查关闭请求，
并且有条件地递增一个计数器。通过关闭标志和计数器，可以确保在关闭日志服务时，所有已经提交的日志都能被写出。</p>
<h4 id="6-2-改进：委托给ExecutorService"><a href="#6-2-改进：委托给ExecutorService" class="headerlink" title="6.2. 改进：委托给ExecutorService"></a>6.2. 改进：委托给ExecutorService</h4><p>简单的程序可以直接在main函数中启动和关闭全局的<code>ExecutorService</code>，而在在复杂的程序中，通常将<code>ExecutorService</code>封装在某个更高级别的服务中，并且该服务能提供自己的生命周期方法。通过封装<code>ExecutorService</code>，
可以将线程的所有权从<code>ExecutorService</code>扩展到服务以及应用程序，所有权链上的各个成员都将管理它所拥有的服务或线程的生命周期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = Executors.newSingleThreadExecutor();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            exec.shutdown();</span><br><span class="line">            exec.awaitTermination(timeout, unit);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> WriteTask(msg));</span><br><span class="line">        &#125;<span class="keyword">catch</span>(RejectedExecutionException e)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-只执行一次的服务"><a href="#7-只执行一次的服务" class="headerlink" title="7. 只执行一次的服务"></a>7. 只执行一次的服务</h3><p>如果某个方法需要处理一批任务，并且当所有任务都处理完成后才返回，那么可以通过一个私有的<code>Executor</code>来简化服务的生命周期管理，这个<code>Executor</code>的生命周期由这个方法来控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//checkMail能在多台主机上并行地检查新邮件，它创建一个私有的Executor，并向每台主机提交一个任务。</span></span><br><span class="line"><span class="comment">//然后，当所有邮件检查任务都执行完成后，关闭Executor，等待结束。</span></span><br><span class="line"><span class="comment">//采用AtomicBoolean代替volatile boolean是因为内部的Runnable可以访问hasNewMail。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkMail</span><span class="params">(Set&lt;String&gt; hosts,<span class="keyword">long</span> timeout,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> AtomicBoolean hasNewMail = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">final</span> String host : hosts)&#123;</span><br><span class="line">                exec.execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(checkMail(host))&#123;</span><br><span class="line">                            hasNewMail.set(<span class="keyword">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            exec.shutdown();</span><br><span class="line">            exec.awaitTermination(timeout, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasNewMail.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-解决ExecutorService-shutdownNow的局限性"><a href="#8-解决ExecutorService-shutdownNow的局限性" class="headerlink" title="8. 解决ExecutorService.shutdownNow的局限性"></a>8. 解决ExecutorService.shutdownNow的局限性</h3><p>当通过<code>shutdownNow</code>来强行关闭<code>ExecutorService</code>时，它会尝试取消正在执行的任务，并返回所有已提交但尚未开始的任务，但无法知道哪些任务已经开始但尚未结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrackingExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Runnable&gt; taskCancellAtShutdown = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;Runnable&gt;());</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrackingExecutor</span><span class="params">(ExecutorService exec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exec = exec;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">getCancelledTasks</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!exec.isTerminated())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Runnable&gt;(taskCancellAtShutdown);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable runnable)</span></span>&#123;</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    runnable.run();</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isShutdown() &amp;&amp; </span><br><span class="line">                       Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                        taskCancellAtShutdown.add(runnable);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将ExecutorService的其他方法委托给exec</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TrackingExecutor通过封装ExecutorService，使得execute或submit记录哪些任务是在关闭后取消的。在Executor结束后，getCancelledTasks返回被取消的任务清单。由于在finally中检测中断状态，
因此如果任务要被记录，在返回时必须维持线程的中断状态，设计良好的任务都应该这样实现。</p>
<p>但TrackingExecutor中存在一个不可避免的竞态条件，可能导致误报。一些被认为取消的任务可能实际上已经完成。在任务执行最后一条指令以及线程池将任务记录为结束的两个时刻之间线程池可能被关闭（已经结束，但线程池未记录）。
如果任务两次执行的结果相同，例如网络爬虫，则可以忽略，否则需要考虑这个风险。</p>
<p><font color="Gray">对于TrackingExecutor存在的竞态问题，如果可以将中断时保存取消的任务这件事委托给任务自己去做，则可以解决。但这里对于TrackingExecutor来讲，它不能假设任务的中断处理方式，
只有在为此专门写的任务以及ExecutorService才能得到保证。之前写过一段练习代码，其中对于BioServer的关闭处理，很多想法和技巧都是来自于本文。地址：<a href="https://github.com/shanhm1991/practice.git。" target="_blank" rel="noopener">https://github.com/shanhm1991/practice.git。</a></font></p>
<ul>
<li>TrackingExecutor的使用示例：网页爬虫<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当爬虫程序必须关闭时，我们通常希望保存它的状态，以便稍后重新启动</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebCrawler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> TrackingExecutor  exec;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;URL&gt; urlsToCrawl = <span class="keyword">new</span> HashSet&lt;URL&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        exec = <span class="keyword">new</span> TrackingExecutor(Executors.newCachedThreadPool());</span><br><span class="line">        <span class="keyword">for</span>(URL url : urlsToCrawl)&#123;</span><br><span class="line">            submitCrawlTask(url);</span><br><span class="line">        &#125;</span><br><span class="line">        urlsToCrawl.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            saveUncrawled(exec.shutdownNow());</span><br><span class="line">            <span class="keyword">if</span>(exec.awaitTermination(timeout,unit))&#123;</span><br><span class="line">                saveUncrawled(exec.getCancelledTasks());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            exec = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;URL&gt; <span class="title">processPage</span><span class="params">(URL url)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveUncrawled</span><span class="params">(List&lt;Runnable&gt; uncrawled)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Runnable task : uncrawled)&#123;</span><br><span class="line">            urlsToCrawl.add(((CrawlTask)task).getPage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">submitCrawlTask</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        exec.execute(<span class="keyword">new</span> CrawlTask(url));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CrawlTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CrawlTask</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.url = url;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(URL link : processPage(url))&#123;</span><br><span class="line">                <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                submitCrawlTask(link);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> URL <span class="title">getPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> url;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="9-处理线程的异常终止"><a href="#9-处理线程的异常终止" class="headerlink" title="9. 处理线程的异常终止"></a>9. 处理线程的异常终止</h3><p>导致线程提前死亡的最主要原因就是<code>RuntimeException</code>，由于这些异常表示出现了某种编程错误或者其他不可修复的错误，因此它们不会被捕获，也不会在调用栈中逐层传递，而是默认在控制台中输出栈追踪信息，并终止线程，从而造成<strong>线程泄露</strong>。</p>
<p>如果任务抛出了一个未检查异常，那么它将使线程终结，但会首先通知框架该线程已经终结。然后，框架可能会用新的线程来代替这个工作线程，也可能不会，因为线程池正在关闭，或者当前已有足够多的线程能满足需要。
<code>ThreadPoolExecutor</code>和<code>Swing</code>都通过这项技巧来确保行为糟糕的任务不会影响到后续任务的执行。</p>
<p>标准线程池允许当发生未捕获异常时结束线程，由于使用try–finally代码块来接收通知，因此当线程结束时，将有新的线程来代替它。如果没有提供捕获异常处理器或者其他的故障通知机制，那么任务会悄悄失败，从而导致混乱。<br>如下为典型的线程池工作者线程结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!isInterrupted())&#123;</span><br><span class="line">                runTask(getTaskFromWorkQueue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">            thrown = e;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            threadExited(<span class="keyword">this</span>,thrown);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread API中也提供了<code>UncaughtExceptionHandler</code>，它能检测出某个线程由于捕获的异常而终结的情况。当一个线程由于捕获异常而退出时，JVM会把这个事件报告给应用程序提供的<code>UncaughtExceptionHandler</code>异常处理器。如果没有任何异常处理器，
那么默认的行为是将栈追踪信息输出到<code>System.err</code>，而通常的响应方式是将一个错误信息以及相应的栈追踪信息写入到日志中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UncaughtExceptionHandler</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">UncaughtExcept</span><span class="params">(Thread t, Throwable e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要为线程池中的所有线程设置一个<code>UncaughtExceptionHandler</code>，需要为<code>ThreadPoolExecutor</code>的构造函数提供一个<code>ThreadFactory</code>，因为只有线程的所有者才能够改变线程的<code>UncaughtExceptionHandler</code>。</p>
<p>另外，只有通过<code>execute</code>提交的任务，才能将抛出的异常交给异常处理器，而通过<code>submit</code>提交的任务，无论抛出的是未检查异常还是已检查异常，都将被任务视为返回状态的一部分。
如果一个由<code>submit</code>提交的任务由于抛出了异常而结束，那么这个异常将在<code>Future.get</code>封装的<code>ExecutionException</code>中重新抛出。</p>
<h3 id="10-守护线程"><a href="#10-守护线程" class="headerlink" title="10. 守护线程"></a>10. 守护线程</h3><p>线程分为两种：<strong>普通线程</strong>和<strong>守护线程</strong>。在JVM启动时创建的所有线程中，除了主线程以外，其他的线程都是守护线程，例如垃圾回收器以及其他执行辅助工作的线程。当创建一个新线程时，新线程将继承创建它的线程的守护状态，
因此在默认情况下，主线程创建的所有线程都是普通线程。</p>
<p>普通与守护的差异仅在当线程退出时发生的操作。当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常退出操作。当JVM停止时，所有仍然存在的守护线程都将被抛弃–即不会执行finally代码块，
也不会执行回卷栈，而JVM只是直接退出。</p>
<p>应尽可能少地使用守护线程—很少有操作能够在不进行清理的情况下被安全地抛弃。特别是，如果在守护线程中执行可能包含I/O操作的任务，那么将是一种危险的行为。</p>
<h3 id="11-关闭钩子"><a href="#11-关闭钩子" class="headerlink" title="11. 关闭钩子"></a>11. 关闭钩子</h3><p>jvm既可以正常地关闭，也可以强行关闭。正常关闭的方式有多种，包括当最后一个非守护线程结束时，或者当调用<code>System.exit</code>时。也可以通过<code>Runtime.halt</code>或者在操作系统中杀死进程来强行关闭。</p>
<p>当正常关闭时，jvm首先调用所有已注册的关闭钩子。关闭钩子指通过<code>Runtime.addShutdownHook</code>注册的但尚未开始的线程。可以注册多个关闭钩子，但jvm并不保证它们的调用顺序，且jvm不会停止或中断任何在关闭时仍然运行的应用线程，
它们将一起并发执行，当jvm最终结束时，这些应用线程将被强行结束。因此关闭钩子应该要保证是线程安全，且在访问共享数据时要小心的避免死锁。当强行关闭时，并不会运行关闭钩子，而只是关闭了jvm。</p>
<p>所以为了避免关闭钩子出现问题，关闭钩子不应该依赖那些可能被应用程序或其他关闭钩子关闭的服务。一种可靠的建议是使用同一个关闭钩子，在钩子中执行一些列串行地操作。</p>
<h3 id="12-终结器"><a href="#12-终结器" class="headerlink" title="12. 终结器"></a>12. 终结器</h3><p>当不再需要内存资源时，可以通过垃圾回收器回收它们，但对于一些资源，例如文件句柄或套接字，当不再需要时，必须显示地交还给操作系统。
因此，为了实现这个功能，java给对象定义了一个终结器<code>finalize()</code>，并且垃圾回收器在释放对象时会检查并执行对象的<code>finalize()</code>，从而释放一些系统资源。</p>
<p>但垃圾回收器的行为是我们不可控的，它的运行策略由jvm决定，因此最好的建议就是避免使用。绝大多情况下，都可以使用try-finally来代替，而且工作的更好。<font color="Gray">这个在《深入理解Java虚拟机》一书中有更详细的介绍，
另外在线程池的实现中可以见到这个方法的使用，因为如果服务关闭时忘了通知它，那么它确实没有其它办法，只能在被回收的时候由垃圾回收器帮忙检查释放线程资源了。</font></p>
<p><br><strong>参考：</strong> </p>
<ol>
<li>Copyright&nbsp;&copy;《java并发编程实战》</li>
</ol>

      
    </div>
	
	
	
    <footer>
      
	  
	    
	<nav id="pagination">
	  
		  <a class="alignleft prev" href="/2019/01/07/20190107/">
		    java并发编程实战.笔记七（线程池的使用）
		  </a>
	  
	  
	  
		  <a class="alignright next" href="/2019/01/05/20190105/">
		    java并发编程实战.笔记五（任务的执行）
		  </a>
	  
	  <div class="clearfix"></div>
	</nav>
	
	    
        
  
  <div class="categories">
    <a href="/categories/读书笔记/">读书笔记</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/《java并发编程实战》/">《java并发编程实战》</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'd7beb7890a79c73a3e3d',
        clientSecret: '80ea1fc195ae4b80cbd65ec9f1ce68d59595af4b',
        id: md5(window.location.pathname),
        repo: 'shanhm1991.github.io',
        owner: 'shanhm1991',
        admin: 'shanhm1991'
    })
    gitalk.render('gitalk-container')
</script>                              



</div></div>
    <aside id="sidebar" class="alignright">
  


  

  

  

  
<div class="widget catlog">
<h3 class="title">Catlog</h3>
<ul class="entry_catlog">
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-自定义取消机制"><span class="toc-text">1. 自定义取消机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-示例：可取消的素数生成器"><span class="toc-text">1.1. 示例：可取消的素数生成器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-中断"><span class="toc-text">2. 中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-示例改进：使用中断实现取消"><span class="toc-text">2.1. 示例改进：使用中断实现取消</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-关于中断策略"><span class="toc-text">2.2. 关于中断策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-关于中断响应"><span class="toc-text">2.3. 关于中断响应</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-示例：任务计时运行"><span class="toc-text">3. 示例：任务计时运行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-在外部线程中安排中断"><span class="toc-text">3.1. 在外部线程中安排中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-改进：在专门的线程中中断任务"><span class="toc-text">3.2. 改进：在专门的线程中中断任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-改进：通过Future来实现取消"><span class="toc-text">3.3. 改进：通过Future来实现取消</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-解决不可中断的阻塞问题"><span class="toc-text">4. 解决不可中断的阻塞问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-改写interrupt将非标准的取消封装在Thread中"><span class="toc-text">4.1. 改写interrupt将非标准的取消封装在Thread中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-改写newTaskFor将非标准的取消封装在任务中"><span class="toc-text">4.2. 改写newTaskFor将非标准的取消封装在任务中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-停止基于线程的服务问题"><span class="toc-text">5. 停止基于线程的服务问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-示例：日志服务的停止"><span class="toc-text">6. 示例：日志服务的停止</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-改进：设置关闭标志"><span class="toc-text">6.1. 改进：设置关闭标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-改进：委托给ExecutorService"><span class="toc-text">6.2. 改进：委托给ExecutorService</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-只执行一次的服务"><span class="toc-text">7. 只执行一次的服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-解决ExecutorService-shutdownNow的局限性"><span class="toc-text">8. 解决ExecutorService.shutdownNow的局限性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-处理线程的异常终止"><span class="toc-text">9. 处理线程的异常终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-守护线程"><span class="toc-text">10. 守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-关闭钩子"><span class="toc-text">11. 关闭钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-终结器"><span class="toc-text">12. 终结器</span></a></li></ol></li></ol>
</div>




</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2020 shanhm1991 
  
  <font style="float: right">
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
