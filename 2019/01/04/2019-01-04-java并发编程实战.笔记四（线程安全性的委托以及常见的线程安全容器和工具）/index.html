<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>java并发编程实战.笔记四（线程安全性的委托以及常见的线程安全容器和工具） | Eassy</title>
  <meta name="author" content="shanhm1991">
  
  <meta name="description" content="引言在上一篇文章中，曾利用过将现场安全性委托给现有的线程安全类的方法。委托是创建线程安全类的一个最有效策略：
只需让现有的线程安全类管理所有的状态即可。Java类库包含丰富的并发基础构建模块，如线程安全的容器以及各种用于协调多个相互协作的线程的同步工具类。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="java并发编程实战.笔记四（线程安全性的委托以及常见的线程安全容器和工具）"/>
  <meta property="og:site_name" content="Eassy"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Eassy" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 4.1.1"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Eassy</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">Abount</a></li>
    
      <li><a href="/books">Books</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-2019-01-04-java并发编程实战.笔记四（线程安全性的委托以及常见的线程安全容器和工具）" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2019-01-03T16:00:00.000Z"><a href="/2019/01/04/2019-01-04-java并发编程实战.笔记四（线程安全性的委托以及常见的线程安全容器和工具）/">2019-01-04</a></time>
      
      
  
    <h1 class="p-name title" itemprop="headline name">java并发编程实战.笔记四（线程安全性的委托以及常见的线程安全容器和工具）</h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在上一篇文章中，曾利用过将现场安全性委托给现有的线程安全类的方法。<font color="LimeGreen">委托是创建线程安全类的一个最有效策略：
只需让现有的线程安全类管理所有的状态即可。</font>Java类库包含丰富的并发基础构建模块，如线程安全的容器以及各种用于协调多个相互协作的线程的同步工具类。</p>
<a id="more"></a>

<h3 id="1-同步容器"><a href="#1-同步容器" class="headerlink" title="1. 同步容器"></a>1. 同步容器</h3><p>这些类的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态，因此同步容器类都是线程安全的。同步容器类是通过其自身的锁来保护它的每个方法，
如果在某些情况下需要额外的客户端加锁来保护复合操作如：迭代或者条件运算（若没有则添加），可以通过获得容器类的锁，在客户端构造原子操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在客户端加锁可以解决不可靠的迭代问题，但会导致在迭代期间其他线程无法访问，降低了并发性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在调用size和get之间存在并发访问</span></span><br><span class="line"><span class="keyword">synchronized</span>(vector)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vector.size(); i++)&#123;</span><br><span class="line">        doSomething(vector.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步容器类的迭代器并没有考虑并发修改的问题，它的策略是‘及时失败’，即当它们发现容器在迭代过程中被修改会及时抛出<code>ConcurrentModificationException</code><font color="Gray">（看过集合类源码的小伙伴肯定见过modCount这个计数，
它表示当前集合对象被修改即新增或删除元素的次数。在每次创建迭代器时会在迭代器实例中记一个计数expectedModCount并置为modCount，
如果在后面的迭代过程中发现了这两个计数值不等即表示在创建完迭代器之后集合发生过改变，就立即抛出异常）</font>。<font color="red">因此要注意的是，即使在单线程中，也可能抛出异常。</font>如果在集合的迭代器的迭代过程中，
直接从容器中删除元素就会抛出这个异常。正确的做法是调用迭代器的删除方法<code>iterator.remove()</code>，它会同时修改<code>modCount</code>和<code>expectedModCount</code>，使它们保持一致。</p>
<p>在多线程环境中要想避免这个异常，就必须在迭代过程中持有容器的锁。如果不想在迭代期间对容器加锁，一种替代的方法就是克隆容器，在副本上进行迭代，但克隆的过程中仍然要对容器加锁，
这种方式的好坏取决于具体场景需求。另外在调用容器的<code>toString</code>，<code>hsahCode</code>，<code>equals</code>，<code>containsAll</code>，<code>removeAll</code>，<code>retainAll</code>等方法时，以及把容器作为参数的构造函数，都会间接的对容器进行迭代，
因此要注意所有这些隐含的迭代操作都可能抛出异常。</p>
<h3 id="2-并发容器"><a href="#2-并发容器" class="headerlink" title="2. 并发容器"></a>2. 并发容器</h3><p>同步容器将所有对容器状态的访问都串行化，以实现他们的线程安全性，这种方法的代价是严重降低了并发性。因此，Java 5.0提供了多种并发容器来改进同步容器的性能。  </p>
<h4 id="2-1-ConcurrentHashMap"><a href="#2-1-ConcurrentHashMap" class="headerlink" title="2.1. ConcurrentHashMap"></a>2.1. ConcurrentHashMap</h4><p>同步容器类在执行每个操作期间都持有一个锁。在一些操作中，例如：<code>HashMap.get</code>或<code>List.contains</code>可能包含大量的工作，当遍历散列桶或链表来查找某个特定的对象时，必须在许多元素上调用<code>equals</code>，
而<code>equals</code>本身也含有一定的计算量。在基于散列的容器中，如果hashCode不能很均匀地分布散列值，那么容器中的元素就不会均匀地分布在整个容器中。某些情况下，
某个糟糕的散列函数还会把一个散列表变成线性链表<font color="Gray">（在jdk1.8之后，HashMap已经改成了用红黑树实现来避免这个问题）</font>。当遍历很长的链表并且在某些或者全部元素上调用<code>equals</code>方法时，
会花费相当长的时间，这段时间内其他线程都不能访问该容器。</p>
<p>与<code>HashMap</code>一样，<code>ConcurrentHashMap</code>也是基于散列的Map，<font color="LimeGreen">但它并不是将每个方法都在同一个锁上同步使得每次只能有一个线程访问容器，而是用一种粒度更细的加锁机制来实现更大程度的共享，
这种机制称为分段锁。</font>这种机制可以提供更高的并发性和伸缩性，任意数量的读取线程可以并发的访问Map，执行读取操作的线程和执行写入操作的线程可以并发的访问Map，
并且一定数量的写入线程可以并发地修改Map，这在并发访问环境下将实现更高的吞吐量，而在单线程环境中只损失非常小的性能。<br><code>ConcurrentHashMap</code>与其他并发容器一起增强了同步容器类，他们提供的迭代器不会抛出<code>ConcurrentModificationException</code>，因此不需要在迭代过程中对容器加锁。它们返回的迭代器具有弱一致性，
弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以（但不保证）在迭代器被构造后将修改操作反映给容器。</p>
<p>尽管有这些改进，但仍然有一些需要权衡的因素。对于一些需要在整个Map上进行计算的方法，比如<code>size()</code>和<code>isEmpty()</code>，这些方法的语义被弱化了以反映容器的并发特性。由于返回的结果可能已经过期了，
而只是一个近似值。但这是允许的，事实上<code>size()</code>和<code>isEmpty()</code>这样的方法在并发环境下的用处很小，因为它们的返回值总在不断变化，从而这些操作的需求也被弱化了，
以换取对其他更重要操作的性能优化，如<code>get</code>，<code>put</code>，<code>containsKey</code>，<code>remove</code>等。<br>另外，<font color="red">由于ConcurrentHashMap不能被加锁来执行独占访问，因此无法使用客户端加锁来创建新的原子操作</font><font color="Gray">（由于我们获取不到想要的锁，
因此客户端加锁也就失去意义）。</font>不过一些常见的复合操作，若没有则添加，若相等则去除，若相等则替换等，都已经实现成了原子操作，并声明在<code>ConcurrentMap</code>中。</p>
<h4 id="2-2-CopyOnWriteArrayList"><a href="#2-2-CopyOnWriteArrayList" class="headerlink" title="2.2. CopyOnWriteArrayList"></a>2.2. CopyOnWriteArrayList</h4><p><code>CopyOnWriteArrayList</code>（<code>CopyOnWriteArraySet</code>类似） 用于替代同步List,在某些情况下提供更好的并发性能，并且在迭代期间不需要对容器进行加锁和复制。<font color="LimeGreen">写入时复制容器的线程安全性在于，
只要正确地发布一个事实不可变对象，那么在访问该对象时就不再需要进一步的同步。</font>在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。容器的迭代器保留一个指向底层基础数组的引用，
这个数组当前位于数组的起始位置，由于它不会被修改，因此在对其进行同步时只需确保数组内容的可见性。因此，多个线程可以同时对这个容器进行迭代，而不会彼此干扰或者与修改容器的线程相互干扰。
容器返回的迭代器不会抛出<code>ConCurrentModificationException</code>,并且返回的元素与迭代器创建时的元素完全一致，而不必考虑之后修改所带来的影响。但是，每当修改容器时都要复制底层数组，
这需要一定的开销，尤其当容器的规模较大时。因此，仅当迭代操作远远多于修改操作时，才应该使用写入时复制容器。</p>
<h4 id="2-3-Queue"><a href="#2-3-Queue" class="headerlink" title="2.3. Queue"></a>2.3. Queue</h4><p><code>Queue</code>用来临时保存一组等待处理的元素。它提供几种实现包括：<code>ConcurentLinkedQueue</code>,传统的先进先出队列。阻塞队列<code>BlockingQueue</code>扩展了<code>Queue</code>，增加了可阻塞的插入和获取等操作。</p>
<p><strong>生产消费模式</strong>中，阻塞队列是常用的方式。阻塞队列提供可阻塞的<code>put</code>和<code>take</code>方法，以及可定时的<code>offer</code>和<code>poll</code>方法。如果队列已经满了，那么<code>put</code>方法阻塞直到有空间可用；如果队列为空，
那么<code>take</code>方法将会阻塞直到有元素可用；相对的<code>offer</code>和<code>poll</code>可以及时返回一个失败状态。队列可以有界也可以无界，无界队列永远都不会充满，因此无界队列的put方法永远也不会阻塞。<br>生产消费模式将要完成的工作与执行工作两个过程分离开来，这样简化了开发过程，消除了生产者类和消费者类之间的代码依赖性，此外，
该模式还将生产数据的过程与使用数据的过程解耦开来以简化工作负载的管理，因为这两个过程在处理数据的速率上有所不同。
一种最常见的生产者-消费者模式就是线程池与工作队列的组合，在<code>Executor</code>任务执行框架中体现了这种模式。</p>
<p>关于<code>BlockingQueue</code>有几种实现：    </p>
<ul>
<li><code>LinkedBlockigQueue</code>和<code>ArrayBlockingQueue</code>是FIFO队列，二者区别分别与<code>LinkedList</code>与<code>ArrayList</code>类似，但比同步List拥有更好的并发性。    </li>
<li><code>PriorityBlockingQueue</code>是一个按优先级排序的队列，既可以根据元素的自然顺序来比较元素（元素实现了<code>Comparable</code>方法），也可以使用<code>Comparator</code>来比较。    </li>
<li><code>SynchronousQueue</code>并不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。
这种区别就好像将文件直接交给同事还是将文件放到他的邮箱中希望他能尽快拿到文件。因为没有存储功能，因此<code>put</code>和<code>take</code>会一直阻塞，直到有另一个线程已经准备好参与到交付过程中。
因此仅当有足够多的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用同步队列。    </li>
</ul>
<h3 id="3-示例：桌面搜索"><a href="#3-示例：桌面搜索" class="headerlink" title="3. 示例：桌面搜索"></a>3. 示例：桌面搜索</h3><p>需求：扫描本地驱动器上的文件并建立索引以便随后进行搜索</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCrawler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;File&gt; fileQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileFilter fileFilter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File root;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            crawl(root);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">crawl</span><span class="params">(File root)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        File[] entries = root.listFiles(fileFilter);</span><br><span class="line">        <span class="keyword">if</span>(entries != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(File entry : entries)&#123;</span><br><span class="line">                <span class="keyword">if</span>(entry.isDirectory())&#123;</span><br><span class="line">                    crawl(entry);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!alreadyIndexed(entry))&#123;</span><br><span class="line">                    fileQueue.put(entry);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Indexer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;File&gt; queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Indexer</span><span class="params">(BlockingQueue&lt;File&gt; queue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                indexFile(queue.take());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例中<code>FileCrawler</code>定义了生产者，在某个文件层次结构中搜索符合索引标准的文件，并将它们的名称放入工作队列。<code>Indexer</code>定义了消费者任务，即从队列中取出文件名称并对它们建立索引。
因此将文件遍历与建立索引分解为独立操作，每个操作只需完成一个任务，并且阻塞队列将负责所有的控制流，因此每个功能的代码都更加简单清晰。<br><font color="LimeGreen">生产消费模式也是利用了线程封闭方法，生产者通过阻塞队列将非线程安全的可变对象的所有权移交给了消费者线程，即安全的发布给了消费者，自始至终对象都只是由单线程拥有，
因此拥有该对象的线程可以对其进行任意修改。</font></p>
<p>Java 6.0开始，增加了双端队列容器类型：<code>Deque</code>和<code>BlockingDeque</code>。它们分别对<code>Queue</code>和<code>BlockingQueue</code>进行了扩展，<code>Deque</code>是一个双端队列，可以在队列头和队列尾进行高效插入和移除，
具体实现有<code>ArrayDeque</code>和<code>LinkedBlockingDeque</code>。</p>
<p>正如阻塞队列适用于生产消费模式，双端队列适用于另一种模式：<strong>工作密取</strong>。在生产消费模式中，所有消费者共享一个工作队列。而<font color="LimeGreen">在工作密取设计中，
每个消费者都有各自的双端队列，如果一个消费者完成了自己双端队列中的工作，那么它可以从其他消费者的双端队列末尾获取工作。密取模式比生产消费模式具有更高的可伸缩性，
因为消费者线程不会在单个共享的任务队列上发生竞争</font><font color="Gray">（这与上面的分段锁是一样的思想，即降低在同一个对象锁上面的竞争程度）</font>。当消费线程访问另一个队列时，
它从队列尾部而不是头部获取任务，也进一步降低了队列上的竞争程度。</p>
<p>密取模式非常适用于<strong>既是生产者也消费者问题</strong>。有时执行某个任务时可能导致更多的任务，比如网页爬虫，处理一个页面时发现更多的页面需要处理，又比如在垃圾回收阶段对堆进行标记问题。
当消费线程发现新的任务时，它可以将其放到自己或其他消费线程的队列末尾。</p>
<h3 id="4-同步工具类"><a href="#4-同步工具类" class="headerlink" title="4. 同步工具类"></a>4. 同步工具类</h3><p>所有的同步工具类都包含一些特定的结构化属性，它们封装了一些状态，这些状态将决定执行同步工具类的线程是继续还是等待。此外还提供了一些方法来对状态进行操作，
以及另一些方法用于高效地等待同步工具类进入到预期状态。</p>
<h4 id="4-1-闭锁"><a href="#4-1-闭锁" class="headerlink" title="4.1. 闭锁"></a>4.1. 闭锁</h4><p>闭锁的作用相当于一扇门，在闭锁到达结束状态之前，这扇门一直是关闭的，没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。当闭锁到达结束状态后，将不会再改变状态，
因此这扇门将永远保持打开状态<font color="Gray">（以后介绍同步工具类的设计时会介绍一种改进版的闭锁：阀门类，它的状态可以重复打开和关闭）</font>。
通常闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。</p>
<p><code>CountDownLatch</code>是一种灵活的闭锁实现，它包括一个计数器，该计数器被初始化成一个正数，表示需要等待的事件数量。<code>countDown()</code>方法递减计数器，表示有一个事件已经发生了，
而<code>await()</code>方法一直等待计数器到零，表示直到所有等待的事件都已经发生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHarness</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTasks</span><span class="params">(<span class="keyword">int</span> nThreads, Runnable task)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThreads);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++)&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">            startGate.await();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">              task.run();</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">              endGate.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;<span class="keyword">catch</span>(InterruptedException ignored)&#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    startGate.countDown();</span><br><span class="line">    endGate.await();</span><br><span class="line">    <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例中启动门使主线程能够同时释放所有工作线程，确保所有的工作线程同时开始工作而达到并发的目的，结束门则使主线程能够等待最后一个线程执行完成，而不是顺序地等待每个线程执行完成。</p>
<h4 id="4-2-FutureTask"><a href="#4-2-FutureTask" class="headerlink" title="4.2. FutureTask"></a>4.2. FutureTask</h4><p><code>FutureTask</code>实现了<code>Future</code>语义，表示一种抽象的可生成结果的计算，通过<code>Callable</code>来实现。它可以处于三种状态：等待运行，正在运行，和运行完成。
运行完成包括所有的可能方式，即正常结束、取消或异常失败，一旦进入完成状态，它将永远停在这个状态上。</p>
<p><code>FutureTask</code>也可以用作闭锁，<code>Future.get()</code>的行为取决于任务的状态，如果任务已经完成，那么立即返回，否则将一直阻塞直到任务完成，然后返回结果或者抛出异常。
显然<code>FutureTask</code>需要确保能够将计算结果从计算线程安全地发布给获取结果的线程。<font color="LimeGreen">通常，FutureTask在Executor框架中表示异步任务，或者用来表示一些耗时计算，
它可以将任务的执行与结果的获取分开</font><font color="Gray">（即可以先启动任务，在需要结果时再进行获取。如果完成了就直接获得结果，即使没有完成从而等待结果，也能省去一部分等待时间）。</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreLoader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;Integer&gt; future =</span><br><span class="line">      <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          <span class="comment">// execute something</span></span><br><span class="line">          <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(future);</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    thread.start();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> future.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-信号量"><a href="#4-3-信号量" class="headerlink" title="4.3. 信号量"></a>4.3. 信号量</h4><p>计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。<br><code>Semaphore</code>中管理着一组虚拟的许可，许可的数量可以通过构造函数来指定。在执行操作前首先获得许可，并在使用后释放。如果没有许可，那么<code>acquire</code>将阻塞直到有许可为止。</p>
<p>通常<code>Semaphore</code>可以用来实现一个可阻塞的资源池，比如我们可以构造一个固定长度的资源池，将<code>Semaphore</code>的计数值初始化为池的大小，使从池中获取资源之前首先<code>acquire</code>一个许可，
在将资源返回池中之后<code>release</code>一个许可，那么在当池为空或满时，资源的获取和释放将变成阻塞直到执行条件成立，而不是直接失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedSet</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; set;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoundedSet</span><span class="params">(<span class="keyword">int</span> bound)</span></span>&#123;</span><br><span class="line">    <span class="comment">//虽然在许可的获取上使用了同步，但随后对set的操作依然存在竞争的风险</span></span><br><span class="line">    set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;T&gt;());</span><br><span class="line">    sem = <span class="keyword">new</span> Semaphore(bound);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    sem.acquire();</span><br><span class="line">    <span class="keyword">boolean</span> added = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      added = set.add(t);</span><br><span class="line">      <span class="keyword">return</span> added;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!added)&#123;</span><br><span class="line">        sem.release();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = set.remove(o);</span><br><span class="line">    <span class="keyword">if</span>(removed)&#123;</span><br><span class="line">      sem.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-栅栏"><a href="#4-4-栅栏" class="headerlink" title="4.4. 栅栏"></a>4.4. 栅栏</h4><p>栅栏类似于闭锁，也阻塞一组线程直到某个事件发生，<font color="red">它们的关键区别在于闭锁用于等待事件，而栅栏用于等待其他线程</font><font color="Gray">（这里不太好理解，换句话说，
就是闭锁通常是让A事件线程等待其他B事件线程使某个条件成立，而栅栏是让一堆类似的事件T线程等待彼此到达一个约定的共同事件点）</font>。
当线程到达栅栏位置时将调用<code>await</code>方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达，那么栅栏将打开，此时所有线程都将被释放，而栅栏将被重置以便下次使用。
如果对<code>await()</code>调用超时或者在<code>await()</code>上阻塞的线程被中断，那么栅栏就认为是被打破了，所有阻塞在<code>await()</code>上线程都将终止并抛出<code>BrokenBarrierException</code>。如果成功地通过栅栏，
那么<code>await()</code>将为每个线程返回一个唯一的到达索引，可以利用这些索引来选举一个领导线程，并在下一次迭代中由该领导线程执行一些特殊的工作。</p>
<p>有些场景中，某些步骤中的计算可以并行执行，但必须等待该步骤中的所有计算都完成后才可以进行下一步。例如，在n-body粒子模拟系统中，每个步骤都根据其他粒子的位置和属性来计算各个粒子的新位置。
通过在两次步骤之间等待栅栏，可以确保在第K步中的所有更新操作都计算完毕，才进入第K+1步。    </p>
<ul>
<li>生命游戏中通过栅栏来计算细胞的自动化模拟：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CellularAutomata</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Board mainBoard;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Worker[] workers;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CellularAutomata</span><span class="params">(Board board)</span></span>&#123;</span><br><span class="line">    mainBoard = board;</span><br><span class="line">    <span class="keyword">int</span> cpuCount = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    barrier = <span class="keyword">new</span> CyclicBarrier(cpuCount, <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mainBoard.commitNewValues();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    workers = <span class="keyword">new</span> Worker[cpuCount];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cpuCount; i++)&#123;</span><br><span class="line">      workers[i] = <span class="keyword">new</span> Worker(mainBoard.getSubBoard(cpuCount, i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workers.length; i++)&#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(workers[i]).start();</span><br><span class="line">    &#125;</span><br><span class="line">    mainBoard.waitForConvergence();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Board board;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Board board)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.board = board;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(!board.hasConvergence())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; board.getMaxX(); x++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; board.getMaxY(); y++)&#123;</span><br><span class="line">            board.setNewValue(x, y, computeValue(x, y));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          barrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
示例中将模拟过程并行化，如果为每个细胞元素分配一个线程是不合适的，过多的线程会导致协调上的开销从而降低计算性能。所以将细胞分成cpuCount份（由于没有IO过程，
当线程数为cpu个数时，吞吐量将最高），所以每个Worker分别计算总细胞数/cpuCount个细胞。<br>每次当<code>Worker</code>计算完一遍子问题中所有的细胞时便会到达栅栏等待，当所有<code>Worker</code>都到达时便一起通过栅栏，然后一起继续下一轮计算， 直到条件<code>hasConvergence()</code>成立，即问题收敛计算完毕。</li>
</ul>
<p>另一种形式的栅栏<code>Exchanger</code>，称为<strong>两方栅栏</strong>，各方在栅栏位置上交换位置。当两方执行不对称的操作时，<code>Exchanger</code>会很有用。例如一个线程向缓存写数据，而另一个线程读取数据，
它们可以使用<code>Exchanger</code>来汇合，并将满的缓存与空的缓存交换。关于交换时机的选择，当缓存被填满时由填充任务交换，当缓存为空时由清空任务交换，这样可以将交换的次数将至最低。
但如果数据的到达不可预测，数据的处理将被延迟，所以可以在缓存被填充到一定程度并保持一定时间后也进行交换。</p>
<h3 id="5-示例：构建一个结果缓存"><a href="#5-示例：构建一个结果缓存" class="headerlink" title="5. 示例：构建一个结果缓存"></a>5. 示例：构建一个结果缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//耗时运算</span></span><br><span class="line">  <span class="function">V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口<code>Computable</code>声明一个函数<code>compute</code>，输入类型为A，输出类型为V。<br>假设它的实现都是一些耗时运算，我们用装饰器模式来给它的实现增加一个缓存功能，用来记住之前的计算结果以便在接收到相同的输入时能直接返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memorizer1</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Memorizer1</span><span class="params">(Computable&lt;A, V&gt; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.c = c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    V result = cache.get(arg);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</span><br><span class="line">      result = c.compute(arg);</span><br><span class="line">      cache.put(arg, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Memorizer1</code>使用<code>HashMap</code>来缓存结果，并使用同步来保证线程安全性，但存在明显的可伸缩性问题，当排队线程较多时甚至可能出现排队时间超过计算本身所需要的时间。</p>
<h4 id="5-1-改进：委托线程安全性给ConcurrentHashMap"><a href="#5-1-改进：委托线程安全性给ConcurrentHashMap" class="headerlink" title="5.1. 改进：委托线程安全性给ConcurrentHashMap"></a>5.1. 改进：委托线程安全性给ConcurrentHashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memorizer2</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Memorizer2</span><span class="params">(Computable&lt;A, V&gt; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.c = c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    V result = cache.get(arg);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</span><br><span class="line">      result = c.compute(arg);</span><br><span class="line">      cache.put(arg, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Memorizer2</code>改进了<code>Memorizer1</code>，使用<code>ConcurrentHashMap</code>代替<code>HashMap</code>，有着更好的并发行为。<code>Memorizer2</code>的问题在于，如果某个线程启动了一个开销很大的计算，
而其他线程并不知道这个计算正在进行，那么很可能会重复这个计算。</p>
<h4 id="5-2-改进：缓存FutureTask代替缓存结果"><a href="#5-2-改进：缓存FutureTask代替缓存结果" class="headerlink" title="5.2. 改进：缓存FutureTask代替缓存结果"></a>5.2. 改进：缓存FutureTask代替缓存结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memorizer3</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Map&lt;A, FutureTask&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Memorizer3</span><span class="params">(Computable&lt;A, V&gt; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.c = c;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(<span class="keyword">final</span> A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    FutureTask&lt;V&gt; f = cache.get(arg);</span><br><span class="line">    <span class="keyword">if</span>(f == <span class="keyword">null</span>)&#123;</span><br><span class="line">      Callable&lt;V&gt; eval = <span class="keyword">new</span> Callable&lt;V&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      f = <span class="keyword">new</span> FutureTask&lt;V&gt;(eval);</span><br><span class="line">      cache.put(arg, f);</span><br><span class="line">      f.run();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> f.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Memorizer3</code>改进了<code>Memorizer2</code>，<code>Memorizer2</code>是检查某个计算是否已经结束，而<code>Memorizer3</code>是检查某个计算是否已经开始。因此它可以表现出更好的并发性，如果结果已经计算出来，将立即返回，
如果有其他线程正在计算结果，那么新到的线程将直接等待这个已经开始的计算完成。但它仍然存在两个线程计算出相同结果的可能，因为if的判断（先检查再执行）并非原子的，
可能多个线程同一时间<code>compute</code>方法，同时没有获取到<code>FutureTask</code>。</p>
<h4 id="5-3-改进：解决先判断后执行问题"><a href="#5-3-改进：解决先判断后执行问题" class="headerlink" title="5.3. 改进：解决先判断后执行问题"></a>5.3. 改进：解决先判断后执行问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memorizer</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Map&lt;A, FutureTask&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Memorizer</span><span class="params">(Computable&lt;A, V&gt; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.c = c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    FutureTask&lt;V&gt; f = cache.get(arg);</span><br><span class="line">    <span class="keyword">if</span>(f == <span class="keyword">null</span>)&#123;</span><br><span class="line">      Callable&lt;V&gt; eval = <span class="keyword">new</span> Callable&lt;V&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;V&gt;(eval);</span><br><span class="line">      f = cache.putIfAbsent(arg, ft);</span><br><span class="line">      <span class="comment">//f代表之前缓存的FutureTask，如果有值就直接丢弃新建的实例ft</span></span><br><span class="line">      <span class="keyword">if</span>(f == <span class="keyword">null</span>)&#123;</span><br><span class="line">        f = ft;</span><br><span class="line">        f.run();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> f.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(CancellationException e)&#123;</span><br><span class="line">      cache.remove(arg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Memorizer</code>改进了<code>Memorizer3</code>，使用原子操作<code>putIfAbsent</code>解决了先检查再执行的问题。<br>但仍然有需要考虑的问题，当缓存的是<code>Future</code>而不是值时，将可能出现缓存污染。如果某个计算被取消或者失败，在获取结果时将知道计算过程被取消或者失败，那么应该将<code>Future</code>从缓存中移除，
这样将来的计算才可能成功。另外<code>Memorizer</code>还需要考虑缓存的逾期和清理等问题。</p>
<ul>
<li>Copyright&nbsp;&copy;《java并发编程实战》</li>
</ul>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/读书笔记/">读书笔记</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/《java并发编程实战》/">《java并发编程实战》</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'd7beb7890a79c73a3e3d',
        clientSecret: '80ea1fc195ae4b80cbd65ec9f1ce68d59595af4b',
        id: window.location.pathname,
        repo: 'shanhm1991.github.io',
        owner: 'shanhm1991',
        admin: 'shanhm1991'
    })
    gitalk.render('gitalk-container')
</script>                              

</div></div>
    <aside id="sidebar" class="alignright">
  


  

  

  
<div class="widget tag">
<h3 class="title">Catlog</h3>
<ul class="entry">
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-同步容器"><span class="toc-text">1. 同步容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-并发容器"><span class="toc-text">2. 并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-ConcurrentHashMap"><span class="toc-text">2.1. ConcurrentHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-CopyOnWriteArrayList"><span class="toc-text">2.2. CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Queue"><span class="toc-text">2.3. Queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-示例：桌面搜索"><span class="toc-text">3. 示例：桌面搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-同步工具类"><span class="toc-text">4. 同步工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-闭锁"><span class="toc-text">4.1. 闭锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-FutureTask"><span class="toc-text">4.2. FutureTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-信号量"><span class="toc-text">4.3. 信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-栅栏"><span class="toc-text">4.4. 栅栏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-示例：构建一个结果缓存"><span class="toc-text">5. 示例：构建一个结果缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-改进：委托线程安全性给ConcurrentHashMap"><span class="toc-text">5.1. 改进：委托线程安全性给ConcurrentHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-改进：缓存FutureTask代替缓存结果"><span class="toc-text">5.2. 改进：缓存FutureTask代替缓存结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-改进：解决先判断后执行问题"><span class="toc-text">5.3. 改进：解决先判断后执行问题</span></a></li></ol></li></ol></li></ol>
</div>




</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2019 shanhm1991
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
