<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>java基础. 容器二. HashMap与LinkedHashMap | Essay</title>
  <meta name="author" content="shanhm1991">
  
  <meta name="description" content="引言1. 概述HashMap的本质就是一个散列表（也称为哈希表），至于什么是散列表可以查一下维基：zh.wikipedia.org/wiki/哈希表，
简单说就是根据一个key通过特定的散列函数计算就可以直接得到对象的地址，这样在key与对象地址之间就存在一个映射关系，使得我们可以通过key很快地获取到目标对象，
于是对象的地址集合就相当于散列表。但是还需要解决地址冲突的问题，就是两个不同的key计算之后得到了同一个地址，通常散列函数能够保证对象之间足够的散列，
出现冲突的概率极低，而如果真的出现了也有对应的解决办法，比如HashMap中采用的就是链表法。
事实上，对象的内存地址就是一个自然的散列表，因为每个对象在内存中的地址必然不同，如果用其内存地址作为key，那么可以保证永远也不会发生冲突。
但实际中不会这样做，因为如果将整个内存作为散列表，那程序其它啥事也不用干了。
java中的Object提供一个方法public native int hashCode();用来返回对象的hash，它就是一个散列函数，即对于任意一个给定的对象，其返回值是确定的；
而对于任意两个不同的对象，返回值相同的概率非常小。关于hashCode的计算实现：java.lang.Object.hashCode()
因此，如果定义一个长度为int最大值的数组，然后用对象的hash作为对象在数组中的位置，对于少数hash相同的对象（hash碰撞）使用链表或者树进行链接，
那我们基本上就可以根据对象的hash直接从数组中进行获取了，少部分可能需要遍历链表或者树。不过大多情况下，程序需要保存的对象个数是有限的，那么将散列表长度定义成int最大值就浪费空间了。如果将长度定义成要保存的对象的个数，
并用对象的hash对数组长度进行取余来获取其在数组中的位置，这样就可以节约空间了，但是显然会增加冲突的概率。
接下来，HashMap的精髓就体现在其解决上面问题的办法了。首先，它提供一个系数，使对象个数与散列表长度之间始终保持一个比例，这样就可以将空间使用率和碰撞概率之间的权衡问题交给使用者自行决定，
默认则取了一个比较折中的值：0.75。另外，考虑到当散列表长度远小于hash值时，取余将变成就直接取hash的最后几位，这很可能会丢失hash的散列特性，
因此，它在取余之前将hash值的高位与低位进行异或以中和其在低位上的散列程度。并且，在实现过程中，它通过tableSizeFor保证散列表的长度为2的幂，
这样在取余时就可以用位运算(table.length - 1) &amp;amp; hash来提高效率了。最后，在发生冲突时会进行元素链接，当链表长度达到一定条件时会转化为红黑树以降低遍历深度，
虽然很多人都喜欢讨论这里链表与红黑树的相互转化问题，但这应该不是HashMap的侧重点，它的本意是作为一个散列表，初衷应该是希望永远不要出现转化为红黑树的情况。
关于红黑树的总结和实现，之前有过完整的梳理：数据结构. 红黑树
由于HashMap是一个散列表，因此它肯定是无序的，至于LinkedHashMap，它其实就是在复用HashMap的基础上加了一个链表结构，维护了对象的插入顺序。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="java基础. 容器二. HashMap与LinkedHashMap"/>
  <meta property="og:site_name" content="Essay"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Essay" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-147251181-1', 'auto');
	ga('send', 'pageview');

</script>


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header id="header" class="inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="alignleft">
  <h1><a href="/">Essay</a></h1>
  <h2><font style="color: #999;">articles:  54 &nbsp;&nbsp;&nbsp; views: <span id="busuanzi_value_site_uv"></span></font></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/about">Abount</a></li>
    
      <li><a href="/books">Books</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>

<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-20170911" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2017-09-10T16:00:00.000Z"><a href="/2017/09/11/20170911/">2017-09-11</a></time>
      
      

  
  
    <h1 class="p-name title" itemprop="headline name">
        java基础. 容器二. HashMap与LinkedHashMap
    </h1>
    
    
       <div class="title" style="padding: 5px 0px 20px 10px; color: #766;">
            ———— JDK 1.8
       </div> 
    
  
  
  


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


   <font style="color: #999;"> words: 9.3k  &nbsp;&nbsp; views: <span id="busuanzi_value_page_pv"></span> &nbsp;&nbsp; time: 42min</font>
   
   
  
  <div class="categories">
    <a href="/categories/java基础/">java基础</a>
  </div>


   
   
  
  <div class="tags">
    <a href="/tags/HashMap/">HashMap</a>   <a href="/tags/LinkedHashMap/">LinkedHashMap</a>
  </div>


   
   <hr style="background-color: #ddd; height:1px; border:none;" /><br>
   


    </header>
      
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>HashMap的本质就是一个散列表（也称为哈希表），至于什么是散列表可以查一下维基：<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="noopener">zh.wikipedia.org/wiki/哈希表</a>，
简单说就是根据一个key通过特定的散列函数计算就可以直接得到对象的地址，这样在key与对象地址之间就存在一个映射关系，使得我们可以通过key很快地获取到目标对象，
于是对象的地址集合就相当于散列表。但是还需要解决地址冲突的问题，就是两个不同的key计算之后得到了同一个地址，通常散列函数能够保证对象之间足够的散列，
出现冲突的概率极低，而如果真的出现了也有对应的解决办法，比如HashMap中采用的就是链表法。</p>
<p>事实上，对象的内存地址就是一个自然的散列表，因为每个对象在内存中的地址必然不同，如果用其内存地址作为key，那么可以保证永远也不会发生冲突。
但实际中不会这样做，因为如果将整个内存作为散列表，那程序其它啥事也不用干了。</p>
<p>java中的<code>Object</code>提供一个方法<code>public native int hashCode();</code>用来返回对象的hash，它就是一个散列函数，即对于任意一个给定的对象，其返回值是确定的；
而对于任意两个不同的对象，返回值相同的概率非常小。关于hashCode的计算实现：<a href="">java.lang.Object.hashCode()</a></p>
<p>因此，如果定义一个长度为int最大值的数组，然后用对象的hash作为对象在数组中的位置，对于少数hash相同的对象（hash碰撞）使用链表或者树进行链接，
那我们基本上就可以根据对象的hash直接从数组中进行获取了，少部分可能需要遍历链表或者树。<br>不过大多情况下，程序需要保存的对象个数是有限的，那么将散列表长度定义成int最大值就浪费空间了。如果将长度定义成要保存的对象的个数，
并用对象的hash对数组长度进行取余来获取其在数组中的位置，这样就可以节约空间了，但是显然会增加冲突的概率。</p>
<p>接下来，HashMap的精髓就体现在其解决上面问题的办法了。<br>首先，它提供一个系数，使对象个数与散列表长度之间始终保持一个比例，这样就可以将空间使用率和碰撞概率之间的权衡问题交给使用者自行决定，
默认则取了一个比较折中的值：0.75。另外，考虑到当散列表长度远小于hash值时，取余将变成就直接取hash的最后几位，这很可能会丢失hash的散列特性，
因此，它在取余之前将hash值的高位与低位进行异或以中和其在低位上的散列程度。并且，在实现过程中，它通过<code>tableSizeFor</code>保证散列表的长度为2的幂，
这样在取余时就可以用位运算<code>(table.length - 1) &amp; hash</code>来提高效率了。最后，在发生冲突时会进行元素链接，当链表长度达到一定条件时会转化为红黑树以降低遍历深度，
虽然很多人都喜欢讨论这里链表与红黑树的相互转化问题，但这应该不是HashMap的侧重点，它的本意是作为一个散列表，初衷应该是希望永远不要出现转化为红黑树的情况。
关于红黑树的总结和实现，之前有过完整的梳理：<a href="https://shanhm1991.github.io/2019/06/10/20190610/">数据结构. 红黑树</a></p>
<p>由于HashMap是一个散列表，因此它肯定是无序的，至于LinkedHashMap，它其实就是在复用HashMap的基础上加了一个链表结构，维护了对象的插入顺序。</p>
<a id="more"></a>

<h3 id="2-HashMap"><a href="#2-HashMap" class="headerlink" title="2. HashMap"></a>2. HashMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-属性"><a href="#2-1-属性" class="headerlink" title="2.1. 属性"></a>2.1. 属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//散列表默认长度：16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表最大长度：2的30次幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表默认负载因子：0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表转化为红黑树的条件1：链表长度&gt;=8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表转化为红黑树的条件2：散列表长度&gt;=64</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树转化为链表的条件：红黑树元素个数&lt;=6</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap自身没有实现Iterator接口，因此不能直接遍历，不过它定义了一个内部类EntrySet。</span></span><br><span class="line"><span class="comment">//EntrySet没有自己的属性，但它能引用到HashMap的所有属性和方法，那么就可以通过遍历EntrySet来间接地遍历了HashMap，</span></span><br><span class="line"><span class="comment">//这里entrySet作为EntrySet的实例将在首次使用时进行初始化。</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素总数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改次数，用来阻止迭代时发生外部修改</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展阈值，当size的值达到threshold时会触发resize()，threshold = table.length * loadFactor</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-1-table"><a href="#2-1-1-table" class="headerlink" title="2.1.1. table"></a>2.1.1. table</h5><p>数组table在内部充当散列表来使用，其元素封装为<code>Node</code>，可以以链表或者红黑树的形式进行链接（当链表长度大于8且table的长度大于64时，会将链表转成红黑树）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">	</span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TreeNode</code>在<code>Node</code>的基础上加了一些红黑树节点的必要属性，不过这里会发现<code>TreeNode</code>是继承的<code>LinkedHashMap.Entry</code>，然后才继承了<code>Node</code>。
按照习惯，通常是会让<code>LinkedHashMap.Entry</code>继承<code>TreeNode</code>，然后<code>TreeNode</code>继承<code>Node</code>。其实都能实现LinkedHashMap对HashMap的复用。<br><font color="red">但是让<code>LinkedHashMap.Entry</code>继承<code>TreeNode</code>将使得LinkedHashMap中所有的节点都包含不必要的<code>TreeNode</code>属性，而在实际中，
红黑树节点应该是小概率事件，因此将会降低LinkedHashMap的空间使用率。而反过来让<code>TreeNode</code>继承<code>LinkedHashMap.Entry</code>的话，
只会使HashMap中少数的红黑树节点拥有不必要的链表属性，影响较小。当存放的对象越小，这种差距将越明显，可能封装成节点之后浪费的空间比对象本身还大。</font></p>
<p>另外，<font color="green"><code>TreeNode</code>也是一个双向链表节点，它有一个<code>prev</code>节点，并且继承了<code>Node</code>的<code>next</code>，它的作用在于方便能够后面的一些操作，
比如<code>HashIterator</code>的迭代处理，另外它能保证在链表转化为红黑树<code>treeifyBin</code>的前后，Map的遍历顺序保持不变，但这点感觉意义不大，
因为<code>HashMap</code>本来就是无序的，而且在进行扩容<code>resize</code>时，还是可能会打乱Map的遍历顺序。</font></p>
<figure class="highlight java"><figcaption><span class="caption">java.util.LinkedHashMap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">            Entry&lt;K,V&gt; before, after;</span><br><span class="line">            Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">                <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><figcaption><span class="caption">java.util.HashMap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">	</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-2-loadFactor"><a href="#2-1-2-loadFactor" class="headerlink" title="2.1.2. loadFactor"></a>2.1.2. loadFactor</h5><p>理想情况下，肯定是希望所有的元素尽量的分散，最好是n个元素平均分布在长度为n的table上。但现实中，总免不了计算出的位置发生碰撞，如果碰撞了，就通过链表或者红黑树来进行链接，
因此，在计算出散列表中的位置后，可能还要对链接的元素进行遍历，并进行hash比较和equals操作（同一个位置下的元素key的hash只是对表长度的取余相等，并不是hash相等）。<br><font color="green">所以<code>HashMap</code>给了一个负载因子<code>loadFactor</code>，其实际存放的元素总数不能超过<code>table.length * loadFactor</code>，记为<code>threshold</code>，
当元素总数达到<code>threshold</code>时就对<code>table.length</code>进行翻倍。那么问题是负载因子的值设为多少合适呢，这时，就需要做一个权衡，如果负载因子比较小，
那么碰撞的概率肯定低了，但空间消耗高了；反之空间利用率肯定高了，但碰撞概率也高了，api中给了一个比较折中的值0.75：</font></p>
<blockquote>
<p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs.<br>Higher values decrease the space overhead but increase the lookup cost<br>(reflected in most of the operations of the HashMap class, including get and put). The<br>expected number of entries in the map and its load factor should be taken into account<br>when setting its initial capacity, so as to minimize the number of rehash operations. If the<br>initial capacity is greater than the maximum number of entries divided by the load factor,<br>no rehash operations will ever occur.   </p>
</blockquote>
<p>意思也差不多：作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，
但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。
如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。
网上也有一些关于0.75取值的讨论，比如：<a href="https://www.jianshu.com/p/64f6de3ffcc1" target="_blank" rel="noopener">HashMap的loadFactor为什么是0.75</a>。</p>
<h4 id="2-2-构造器"><a href="#2-2-构造器" class="headerlink" title="2.2. 构造器"></a>2.2. 构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-静态工具"><a href="#2-3-静态工具" class="headerlink" title="2.3. 静态工具"></a>2.3. 静态工具</h4><h5 id="2-3-1-tableSizeFor"><a href="#2-3-1-tableSizeFor" class="headerlink" title="2.3.1. tableSizeFor"></a>2.3.1. tableSizeFor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="green"><code>tableSizeFor</code>方法是用来设置<code>HashMap</code>中散列表的长度，它确保返回一个大于且最靠近给定数的2的幂，这样做的用意是为了提高后面取余计算的效率。
其实现得非常巧妙，它通过5次无符号右移以及位或运算，将任意一个以二进制表示的数的最高位往右至多32位全部置为1，然后再加1，这样使得所有位都进1，
最后刚好得到一个比给定数高1位的2的幂。</font>其实刚好满足一个等比式：(1 + 2 + 2^2 + … + 2^n) + 1 = 2^(n+1),  n &lt;= 32。<br>并且运算之前会首先将给定数减1，以确保结果不会超过给定数。如果给定数刚好为2^x，那么减1之后最高位将为2^(x-1)，这样运算后进位的结果依然为2^x，
而如果给定数为2^(x-1) + m,  1 &lt;= m &lt; 2^(x-1), 结果肯定也是2^x。另外，考虑到int有效值区间，方法设置了返回值的上下界：2^0 ~ 2^30。   </p>
<h5 id="2-3-2-hash"><a href="#2-3-2-hash" class="headerlink" title="2.3.2. hash"></a>2.3.2. hash</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="green">hash方法用来给出key的hash，后面会用<code>table.length</code>对这个hash取余来计算其在table中的位置。
源码中为了运算效率使用的位运算：<code>(table.length - 1) &amp; hash</code>，等价于<code>hash % table.length</code>，但是前提是<code>table.length</code>必须为2的幂，
这样<code>table.length - 1</code>才能保证除最高位之外所有位全部为1，然后和<code>hash</code>进行位与运算就可以直接得出<code>length</code>对于<code>hash</code>的余数，
这也正是前面<code>tableSizeFor</code>的用意。</font></p>
<p><font color="green">并且，hash方法在返回key的hash值之前，会先将它hash值的高位与低位进行异或。
由于table的长度一般会远小于key的hash值（table长度默认为2^4，也就是只有4位）。如果直接进行取余，那么就相当于取hash的低3位的值，那这样发生冲突的概率还是比较高的。
因为，虽然hash值的散列特性很好，但它的散列区间很大，就是int取值范围，它并不会保证在低位上的散列特性。试想如果给定n个key，计算得出的hash值在低位完全相同，
而高位全部不同，那么对于散列函数来说，它已经达到散列的要求了，但此时如果取余计算它们在table中的位置，将全部在一起。因此，
设计者考虑将hash的高位与低位先进行异或，这样可以中和一下高位和低位的散列特性，而且这样做不会增加多少性能开销。</font></p>
<p>最后，对于null值key，返回固定值0，因此最终只能存在一个key为null的元素，它将与其它hash取余为0的元素一起放在散列表的第0位。</p>
<h4 id="2-4-接口实现"><a href="#2-4-接口实现" class="headerlink" title="2.4. 接口实现"></a>2.4. 接口实现</h4><p>HashMap实现的接口有很多，这里只说一下它主要的接口，比如put、remove、遍历、以及涉及到的一些有关<code>TreeNode</code>的操作。</p>
<h5 id="2-4-1-put"><a href="#2-4-1-put" class="headerlink" title="2.4.1. put"></a>2.4.1. put</h5><p>先概括下思路：<br><font color="green">首先根据hash计算在table中对应的位置，如果对应位置为空，那么直接新建并插入一个链表节点；<br>否则，尝试从位置下面的节点中寻找一个重复key的节点，并记为e，如果没找到，就直接插入，e为空；（具体位置上可能是单节点或者链表或者红黑树，
细节有点区别但思路都是一致的）<br>最后，如果e不为空，即发生了插入，那么再检查元素的总数是否超过了阈值<code>threshold</code>，来决定是否扩容。</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果table为空或其长度为0，则进行初始化</span></span><br><span class="line">	<span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">		n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果根据hash计算，发现table中对应位置为空，则直接新建并插入一个Node&lt;K,V&gt;</span></span><br><span class="line">	<span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">		tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">	<span class="comment">//否则，尝试从对应位置下面寻找一个与给定key重复的Node&lt;K,V&gt;，并记为e，</span></span><br><span class="line">	<span class="comment">//如果没有找到，则新建并插入节点，e将为null</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		Node&lt;K,V&gt; e; K k;</span><br><span class="line">		<span class="comment">//如果位置下面第一个Node&lt;K,V&gt;就发现hash和key相同，那么直接记为e</span></span><br><span class="line">		<span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">			e = p;</span><br><span class="line">		<span class="comment">//否则如果是红黑树，与下面链表的思路一致，具体见2.4.4.1</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">			e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">		<span class="comment">//否则就是链表，尝试找到重复key的节点并记为e，否则直接插入并将e记为null</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">			        <span class="comment">//如果遍历到链表最后也没有找到，那么直接新建并添加到链表末尾</span></span><br><span class="line">				<span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">					p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">					<span class="comment">//新增之后如果链表长度&gt;=8，则对table长度进行翻倍或者将链表转化为红黑树</span></span><br><span class="line">					<span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">						treeifyBin(tab, hash);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">                                <span class="comment">//如果key重复，则将节点记为e，并结束遍历</span></span><br><span class="line">				<span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//将e记为p，以便继续向下遍历	 </span></span><br><span class="line">				p = e;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果找到了重复元素e，就进行值替换，并返回旧值</span></span><br><span class="line">		<span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">			V oldValue = e.value;</span><br><span class="line">			<span class="comment">//若onlyIfAbsent为true，且原来value不为null，则直接忽略；否则直接覆盖value</span></span><br><span class="line">			<span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)  </span><br><span class="line">				e.value = value;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//抽出一个方法，留给子类LinkedHashMap实现后续的操作</span></span><br><span class="line">			afterNodeAccess(e); </span><br><span class="line">			<span class="keyword">return</span> oldValue;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//否则必定发生了新增，所以修改次数加1</span></span><br><span class="line">	++modCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果新增后元素总数超过了阈值threshold，则对table长度进行翻倍</span></span><br><span class="line">	<span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">		resize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//抽出一个方法，留给子类LinkedHashMap实现后续的操作</span></span><br><span class="line">	afterNodeInsertion(evict); </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个链表转化为红黑树的过程，如果链表新增之后长度&gt;=8，并且table的长度&gt;=64，那么会将对应的链表转化为红黑树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">	<span class="comment">//如果表的长度小于64，那么就简单地将表的长度进行翻倍</span></span><br><span class="line">	<span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">		resize();</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//先将所有的Node&lt;K,V&gt;转变成TreeNode&lt;K,V&gt;</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">				<span class="comment">//hd用来记住链表头节点</span></span><br><span class="line">				hd = p; </span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//tl用来循环链接节点，可以维护节点转化为红黑树节点之前的顺序，</span></span><br><span class="line">				<span class="comment">//这样在后面HashIterator中利用next进行迭代时顺序将不受影响</span></span><br><span class="line">				p.prev = tl; </span><br><span class="line">				tl.next = p;</span><br><span class="line">			&#125;</span><br><span class="line">			tl = p;</span><br><span class="line">		&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//然后进行红黑树的插入，具体见2.4.4.2</span></span><br><span class="line">		<span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">			hd.treeify(tab);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一下resize()方法，它负责对<code>table</code>以及<code>threshold</code>进行初始化或扩容。当table进行扩容之后，需要遍历<code>oldTab</code>将其中的节点放到<code>newTab</code>中，
这里对于计算节点在<code>newTab</code>中位置的处理非常巧妙：<br><font color="green">因为<code>oldCap</code>是2的幂，且newCap = oldCap * 2，看成二进制就是<code>newCap</code>比<code>oldCap</code>多了一位，那么它们在对<code>hash</code>取余时的区别，
也就是<code>newCap</code>多取了一位（即<code>oldCap</code>的最高位），因此关键就看<code>hash</code>在这一位的值是0还是1：如果是0则取余相同，即位置相同；
如果为1，则<code>newCap</code>的取余刚好比<code>oldCap</code>的取余多一个最高位的值，即相差一个<code>oldCap</code>；
因此，最终将节点在<code>newCap</code>中位置的计算转换成判断<code>hash</code>在<code>oldCap</code>最高位是0还是1的问题。</font></p>
<p>所以，当位置上是链表或红黑树，即存在多个节点时，它们放到<code>newTab</code>中只有两种情况：要么位置不变，要么刚好相差<code>oldCap</code>。因此将节点分为两组，并提前链接好，
最后将两组的头结点放到<code>newTab</code>中对应的位置即可。比如下面链表处理时的<code>loHead</code>和<code>hiHead</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果table已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果table的长度&gt;=MAXIMUM_CAPACITY，那么直接将threshold也放到MAXIMUM_CAPACITY，table保持不变</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果table的长度&gt;=16，且翻倍后&lt;MAXIMUM_CAPACITY，那么将threshold也翻倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果table没有初始化，但threshold有值，那么将table的长度记为threshold</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">//否则将table的长度和threshold都设为默认值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;              </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//确保newThr被正确的赋值，</span></span><br><span class="line">    <span class="comment">//因为当oldCap为MAXIMUM_CAPACITY/2，或者当table没有初始化但oldThr有值时，newThr将为0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//创建newTab，并遍历oldTab将其中的节点放到newTab中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//如果位置上元素不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当节点类型发生变化的时候可以加快对象的回收，</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>; </span><br><span class="line">				</span><br><span class="line">                <span class="comment">//如果位置上只有一个节点，则直接计算该节点在newTab中的位置；</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果位置上是红黑树节点，思路与下面的链表一致，具体见2.4.4.3</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//否则位置上就是链表节点</span></span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;                               </span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//若=0，则节点在newTab中位置不变，将头节点记为loHead，并用loTail进行循环链接</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;  </span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//若=1，则节点在newTab中位置相差oldCap，将头节点记为hiHead，并用hiTail进行循环链接</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;                        </span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">					</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-2-remove"><a href="#2-4-2-remove" class="headerlink" title="2.4.2. remove"></a>2.4.2. remove</h5><p><code>remove</code>的思路比较简单：尝试从map中寻找相同key的节点，如果找到就删除并返回，否则返回空，注意即使删除后节点个数小于阈值6，也不会转化为链表，
这个转化只会发生在扩容进行拆分时。这里复杂的地方在于红黑树中节点的删除，不过不作讨论，之前已经专门整理过红黑树相关的操作实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt; e;</span><br><span class="line">	<span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?  <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//matchValue = false; movable = true;</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">        <span class="comment">//如果tab不为空，并且对应位置下面有节点</span></span><br><span class="line">	<span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">                <span class="comment">//尝试找到key相同的节点，并记为node</span></span><br><span class="line">		<span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">			node = p;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">				node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">do</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (e.hash == hash </span><br><span class="line">                                            &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">						node = e;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					p = e;</span><br><span class="line">				&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//如果找到了，并且不需要比较value或者value相同，那么进行删除操作</span></span><br><span class="line">		<span class="keyword">if</span> (node != <span class="keyword">null</span> </span><br><span class="line">                    &amp;&amp; (!matchValue || (v = node.value) == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                        <span class="comment">//如果是红黑树则进行红黑树的节点删除，否则直接修改next即可</span></span><br><span class="line">			<span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">				((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">				tab[index] = node.next;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				p.next = node.next;</span><br><span class="line">			++modCount;</span><br><span class="line">			--size;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//交给LinkedHashMap扩展</span></span><br><span class="line">			afterNodeRemoval(node);</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//否则没有找到，返回null</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-3-entrySet"><a href="#2-4-3-entrySet" class="headerlink" title="2.4.3. entrySet"></a>2.4.3. entrySet</h5><p>在属性中有一项<code>entrySet</code>，它的<font color="green">类型<code>EntrySet</code>并没有任何属性状态，但它作为内部类可以访问到HashMap的所有属性和方法，
因此HashMap可以返回一个<code>EntrySet</code>的实例，这样我们就可以调用<code>EntrySet</code>提供的方法，比如遍历，并通过它访问到HashMap的内部状态，
而且当HashMap的状态发生变化时也能通过<code>EntrySet</code>体现出来。这种将外部接口实现为私有内部类的方式在api中随处可见，也是内部类的经典使用方式。</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        Object key = e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Object value = e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="comment">//这里可以看到遍历过程，依次遍历table的每个位置下个各个节点，节点直接通过next访问下一个</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一下迭代器的实现，一般<code>EntrySet</code>再迭代时也是通过其返回一个内部实现的迭代器来进行的，主要就是这里维护的一个<code>next</code>的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化迭代的起始位置：index为tab中第一个不为空的位置，next为该位置下的第一个节点     </span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="comment">//如果Map的修改次数与迭代开始时不同，则及时异常结束</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">			</span><br><span class="line">        <span class="comment">//modCount是在元素实际删除之后修改的，如果多线程操作情况下,</span></span><br><span class="line">        <span class="comment">//可能会发现修改次数还没来得及变化，但实际元素已经被删除的状态</span></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">			</span><br><span class="line">        <span class="comment">//遍历的实现：</span></span><br><span class="line">        <span class="comment">//首先看next的后面是否还有节点，如果有就将next记为下一个节点，并返回当前节点；</span></span><br><span class="line">        <span class="comment">//如果没有，再看下一个不为空的位置，与初始化时一样的做法</span></span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="comment">//防止多线程情况下不可预测的情况</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//通过迭代器删除会将expectedModCount重置，</span></span><br><span class="line">        <span class="comment">//因此不会出现ConcurrentModificationException</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-4-TreeNode"><a href="#2-4-4-TreeNode" class="headerlink" title="2.4.4. TreeNode"></a>2.4.4. TreeNode</h5><p>这里只是稍微补充下上面代码中涉及的有关<code>TreeNode</code>的操作，并不赘述红黑树相关的内容。</p>
<h6 id="2-4-4-1-putTreeVal"><a href="#2-4-4-1-putTreeVal" class="headerlink" title="2.4.4.1 putTreeVal"></a>2.4.4.1 putTreeVal</h6><p>从上面<code>putVal</code>中的代码可以知道<code>putTreeVal</code>的用意：尝试找到并返回一个重复key的节点；如果没有找到就插入新节点，并返回null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">	Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">	TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//从根节点开始遍历，记为p，并将p.hash与给定的h进行比较，将结果记为dir</span></span><br><span class="line">	<span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">		<span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">		<span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">			dir = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">			dir = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果p.hash = h，并且p.key与k比较相同，则直接返回p</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">                <span class="comment">//否则就是p.hash = h，并且p.key与k比较不相同，那么尝试通过key自身比较大小，</span></span><br><span class="line">                <span class="comment">//如果依然比较不出大小</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; (kc = comparableClassFor(k)) == <span class="keyword">null</span>) </span><br><span class="line">				|| (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//先尝试从p节点的左右子树中寻找相同key的节点，searched保证只做一次尝试</span></span><br><span class="line">			<span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">				TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">				searched = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp; (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) </span><br><span class="line">				    || ((ch = p.right) != <span class="keyword">null</span> &amp;&amp; (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">					<span class="keyword">return</span> q;</span><br><span class="line">			&#125;</span><br><span class="line">                        <span class="comment">//进行最后的比较，必须要比较出一个大小，不然没法进行二叉树的插入</span></span><br><span class="line">			dir = tieBreakOrder(k, pk);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//红黑树的遍历，以及红黑树和双向链表的插入处理</span></span><br><span class="line">		<span class="comment">//当遍历到xp的left或right为null时，也就找到了新建节点x待插入的位置</span></span><br><span class="line">                <span class="comment">//这里除了红黑树的插入，还维护了一个双向链表：由xp &lt;-&gt; xpn 变为 xp &lt;-&gt; x &lt;-&gt; xpn </span></span><br><span class="line">		TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">		<span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">			Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">			TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">			<span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">				xp.left = x;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				xp.right = x;</span><br><span class="line">			xp.next = x;</span><br><span class="line">			x.parent = x.prev = xp;</span><br><span class="line">			<span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">				((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">			<span class="comment">//红黑树的平衡操作</span></span><br><span class="line">			moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">			<span class="comment">//发生插入后返回null</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>putTreeVal</code>中发现两个key的hash相等，而比较却又不相同时，会尝试通过key本身进行大小比较，首先通过<code>comparableClassFor</code>看它是否是可比较的<code>Comparable</code>类型，
如果是就在<code>compareComparables</code>中做类型强转并进行比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">        <span class="comment">//String直接返回，String implements Comparable&lt;String&gt;</span></span><br><span class="line">        <span class="keyword">if</span> ((c = x.getClass()) == String<span class="class">.<span class="keyword">class</span>) // <span class="title">bypass</span> <span class="title">checks</span></span></span><br><span class="line"><span class="class">            <span class="title">return</span> <span class="title">c</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//否则获取类型c实现的接口列表</span></span><br><span class="line">        <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">		<span class="comment">// 如果t是泛型接口；并且原始类型是Comparable；</span></span><br><span class="line">                <span class="comment">// 并且t的泛型参数有且仅有一个；并且泛型参数就是c。那么返回c</span></span><br><span class="line">                <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) </span><br><span class="line">                        &amp;&amp; ((p = (ParameterizedType)t).getRawType() == Comparable<span class="class">.<span class="keyword">class</span>) </span></span><br><span class="line"><span class="class">                        &amp;&amp; (<span class="title">as</span> </span>= p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp; as.length == <span class="number">1</span> </span><br><span class="line">                        &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> : ((Comparable)k).compareTo(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上面的尝试依然失败，即key的类型不可比较或者比较结果依然相等，那么就做进行最后的努力：首先比较类名，如果还是相等，
那么就调用本地方法<code>System.identityHashCode</code>计算两个对象的hashcode，就算最后算出的结果相等也视为小于，总之强行比较出一个大小关系。<br>这就解释了为什么当上面无法比较出大小时，首先尝试从左右子树中寻找相同key的节点了。因为确实可能存在equals不同，但怎么比较都分不出大小的节点，
不过可以确定它们一定是相邻的节点，新插入的节点会放到左子树，但平衡操作也可能旋转到右子树，因此需要从左右子树中都尝试找一下。
由于寻找是遍历当前节点下面所有的子节点，因此只需要尝试一次即可，所以通过<code>searched</code>来控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> d;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span> </span><br><span class="line">	 || b == <span class="keyword">null</span> </span><br><span class="line">	 || (d = a.getClass().getName(). compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">		d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-4-4-2-treeify"><a href="#2-4-4-2-treeify" class="headerlink" title="2.4.4.2 treeify"></a>2.4.4.2 treeify</h6><p>从上面<code>treeifyBin</code>中的代码知道，调用这个方法的对象是<code>tab</code>某位置下面链表的头节点，也就是这里的<code>this</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">	TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">		next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">		x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//第一个节点为根节点</span></span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">			x.parent = <span class="keyword">null</span>;</span><br><span class="line">			x.red = <span class="keyword">false</span>;</span><br><span class="line">			root = x;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			K k = x.key;</span><br><span class="line">			<span class="keyword">int</span> h = x.hash;</span><br><span class="line">			Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">			<span class="comment">//从根节点开始遍历直到找到为null的树叶位置进行插入然后平衡，</span></span><br><span class="line">			<span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">				<span class="keyword">int</span> dir, ph;</span><br><span class="line">				K pk = p.key;</span><br><span class="line">				<span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">					dir = -<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">					dir = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; (kc = comparableClassFor(k)) == <span class="keyword">null</span>) </span><br><span class="line">					  ||(dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">					dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">				TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">				<span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">					x.parent = xp;</span><br><span class="line">					<span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">						xp.left = x;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						xp.right = x;</span><br><span class="line">					root = balanceInsertion(root, x);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-4-4-3-split"><a href="#2-4-4-3-split" class="headerlink" title="2.4.4.3 split"></a>2.4.4.3 split</h6><p>从上面<code>resize</code>的实现可以知道，当发生扩容时，会将<code>oldTab</code>中红黑树拆分到<code>newTab</code>中，并且可以确定，树中的节点最多拆到<code>newTab</code>中的两个位置下面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(T1&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">	TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//先与之前链表的处理一样，将所有节点拆为两组，并记录每组的个数</span></span><br><span class="line">	TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">	TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">		next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">		e.next = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">				loHead = e;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				loTail.next = e;</span><br><span class="line">			loTail = e;</span><br><span class="line">			++lc;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">				hiHead = e;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				hiTail.next = e;</span><br><span class="line">			hiTail = e;</span><br><span class="line">			++hc;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果拆分后发现节点个数&lt;=6，那么将节点转变成链表节点</span></span><br><span class="line">		<span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">			tab[index] = loHead.untreeify(map);</span><br><span class="line">                <span class="comment">//否则进行红黑树的插入，与上面一样</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			tab[index] = loHead;</span><br><span class="line">			<span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">				loHead.treeify(tab);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//与loHead的处理一样，只是在tab中的位置不一样</span></span><br><span class="line">	<span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">			tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			tab[index + bit] = hiHead;</span><br><span class="line">			<span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">				hiHead.treeify(tab);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-LinkedHashMap"><a href="#3-LinkedHashMap" class="headerlink" title="3. LinkedHashMap"></a>3. LinkedHashMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>LinkedHashMap</code>基本是复用了<code>HashMap</code>的实现，一些涉及到修改的地方都是<code>HashMap</code>提供一个模板方法，将过程中的一些步骤抽出来给<code>LinkedHashMap</code>去实现或覆盖。
只是除了迭代过程不一样，因为它希望能按照元素放入的顺序来进行遍历。</p>
<h4 id="3-1-属性"><a href="#3-1-属性" class="headerlink" title="3.1. 属性"></a>3.1. 属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表头节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表尾节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//true：基于访问顺序，false：基于插入顺序，默认false</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-构造器"><a href="#3-2-构造器" class="headerlink" title="3.2. 构造器"></a>3.2. 构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-接口实现"><a href="#3-3-接口实现" class="headerlink" title="3.3 接口实现"></a>3.3 接口实现</h4><h5 id="3-3-1-put-remove"><a href="#3-3-1-put-remove" class="headerlink" title="3.3.1. put/remove"></a>3.3.1. put/remove</h5><p>上面说了，LinkedHashMap的操作都是直接复用的HashMap实现，只添加了少量额外的操作，比如下面：<br>它覆盖了put中创建节点的方法，在里面加了一个链表的链接操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它节点删除之后，维护了一下自己的链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将删除节点记为p，通过修改它前后节点的引用将其跳过</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果accessOrder为true，即按照访问顺序进行遍历，那么在每次访问之后，它将访问节点放到最后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-2-entrySet"><a href="#3-3-2-entrySet" class="headerlink" title="3.3.2. entrySet"></a>3.3.2. entrySet</h5><p>从迭代器<code>LinkedHashIterator</code>的实现中可以看到，它没有去遍历<code>table</code>，而是从<code>head</code>开始访问一直到<code>after</code>为null结束，即遍历的自己维护的一个链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> LinkedEntrySet()) : es;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; LinkedHashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedEntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        Object key = e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Object value = e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.SIZED |</span><br><span class="line">                                        Spliterator.ORDERED |</span><br><span class="line">                                        Spliterator.DISTINCT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">            action.accept(e);</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntryIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashIterator</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; next;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; current;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount;</span><br><span class="line"></span><br><span class="line">    LinkedHashIterator() &#123;</span><br><span class="line">        next = head;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> LinkedHashMap.<span class="function">Entry&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        current = e;</span><br><span class="line">        next = e.after;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
	
    <footer>
      
	  
	    
	<nav id="pagination">
	  
		  <a class="alignleft prev" href="/2017/09/12/20170912/">
		    java基础. 容器三. TreeMap以及Set
		  </a>
	  
	  
	  
		  <a class="alignright next" href="/2017/09/10/20170910/">
		    java基础. 容器一. ArrayList与LinkedList
		  </a>
	  
	  <div class="clearfix"></div>
	</nav>
	
	    
        
  
  <div class="categories">
    <a href="/categories/java基础/">java基础</a>
  </div>


        
  
  <div class="tags">
    <a href="/tags/HashMap/">HashMap</a>   <a href="/tags/LinkedHashMap/">LinkedHashMap</a>
  </div>


        
  <div class="addthis addthis_toolbox addthis_default_style">
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'd7beb7890a79c73a3e3d',
        clientSecret: '80ea1fc195ae4b80cbd65ec9f1ce68d59595af4b',
        id: md5(window.location.pathname),
        repo: 'shanhm1991.github.io',
        owner: 'shanhm1991',
        admin: 'shanhm1991'
    })
    gitalk.render('gitalk-container')
</script>                              



</div></div>
    <aside id="sidebar" class="alignright">
  


  

  

  

  
<div class="widget catlog">
<h3 class="title">Catlog</h3>
<ul class="entry_catlog">
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-概述"><span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-HashMap"><span class="toc-text">2. HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-属性"><span class="toc-text">2.1. 属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-table"><span class="toc-text">2.1.1. table</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-2-loadFactor"><span class="toc-text">2.1.2. loadFactor</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-构造器"><span class="toc-text">2.2. 构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-静态工具"><span class="toc-text">2.3. 静态工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-tableSizeFor"><span class="toc-text">2.3.1. tableSizeFor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-hash"><span class="toc-text">2.3.2. hash</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-接口实现"><span class="toc-text">2.4. 接口实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-1-put"><span class="toc-text">2.4.1. put</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-2-remove"><span class="toc-text">2.4.2. remove</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-3-entrySet"><span class="toc-text">2.4.3. entrySet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-4-TreeNode"><span class="toc-text">2.4.4. TreeNode</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-4-4-1-putTreeVal"><span class="toc-text">2.4.4.1 putTreeVal</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-4-4-2-treeify"><span class="toc-text">2.4.4.2 treeify</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-4-4-3-split"><span class="toc-text">2.4.4.3 split</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-LinkedHashMap"><span class="toc-text">3. LinkedHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-属性"><span class="toc-text">3.1. 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-构造器"><span class="toc-text">3.2. 构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-接口实现"><span class="toc-text">3.3 接口实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-put-remove"><span class="toc-text">3.3.1. put&#x2F;remove</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-entrySet"><span class="toc-text">3.3.2. entrySet</span></a></li></ol></li></ol></li></ol></li></ol>
</div>




</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">

  
  
      &copy; 2020 shanhm1991 
  
  
  
  <font style="float: right">
</div>
<div class="clearfix"></div>
</footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
