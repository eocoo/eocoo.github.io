<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>设计模式. 单例模式 | Essay</title>
  <meta name="author" content="shanhm1991">
  
  <meta name="description" content="引言设计模式的原则
开闭原则

即对扩展开放，对修改封闭。在程序需要扩展的时候，不要去修改原有的代码，而是扩展原有代码，实现一个热插拔的效果。

单一职责原则

不要存在多于一个导致类变更的原因，也就是说每个类的职责应该单一，否则就应该把类进行拆分。

里氏替换原则

任何引用基类的地方必须能透明地使用其子类的对象。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，
而衍生类也能够在基类的基础上增加新的行为。

依赖倒转原则

面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不要直接与具体类交互，而与具体类的上层接口交互。

接口隔离原则

每个接口中不存在子类用不到却必须实现的方法，否则，就应该将接口拆分，使用多个隔离的接口。

迪米特法则（最少知道原则）

一个类对自己依赖的类知道的越少越好，无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。
设计模式的分类
创建型模式

工厂模式、单例模式、建造者模式、原型模式等

结构型模式

适配器模式、组合模式、装饰器模式、代理模式、门面模式、桥接模式、享元模式等

行为型模式

策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、访问者模式、调停者模式等
设计模式的使用设计模式的目标在于保证程序的高可用以及高扩展性，在实际开发的过程中不应过多地纠结使用哪种设计模式，而是应该多体会设计模式的原则，换言之，
只要遵循一定的原则，这些所谓的模式完全可能在无意识的状态下自发出现在产品代码中。其实这些设计模式也不是谁突然间硬想出来的，而是早已存在并广泛使用的做法，它们来自于好的做法的总结。  
好的设计能够有效地避免或者延缓程序架构的腐化，通常，很多程序一开始的结构也许设计得还可以，但随着业务功能的不断扩展和变化，
可能就不得不在结构上做出一些妥协让步，慢慢地也就失去了结构。但是，在设计过程中需要注意避免过度设计，即为可能发生的变动支付了过多的复杂度代价。不要滥用设计模式，觉得一个地方有可能会变动，
就忍不住考虑是否应该增加复杂度来换取灵活性。要避免过度设计，关键在于能正确的预见变化，以及权衡所引入的复杂度相对于发生变化的可能性和破坏力是否值得，这需要经验的积累以及对业务的认识。
1. 单例模式单例模式的意思就是确保某个类在系统中只有一个实例，概括起来即以下三点：

只能有一个类实例；
类必须自行创建这个实例；
类必须自行向整个系统提供这个实例。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="设计模式. 单例模式"/>
  <meta property="og:site_name" content="Essay"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Essay" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-147251181-1', 'auto');
	ga('send', 'pageview');

</script>


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header id="header" class="inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="alignleft">
  <h1><a href="/">Essay</a></h1>
  <h2><font style="color: #999;">articles:  44 &nbsp;&nbsp;&nbsp; views: <span id="busuanzi_value_site_uv"></span></font></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/about">Abount</a></li>
    
      <li><a href="/books">Books</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>

<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-20171001" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2017-09-30T16:00:00.000Z"><a href="/2017/10/01/20171001/">2017-10-01</a></time>
	  
      
  
    <h1 class="p-name title" itemprop="headline name">设计模式. 单例模式</h1>
	
  

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<font style="color: #999;">words: 3.8k &nbsp;&nbsp;&nbsp; views: <span id="busuanzi_value_page_pv"></span></font>

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h3><ol>
<li>开闭原则</li>
</ol>
<p>即对扩展开放，对修改封闭。在程序需要扩展的时候，不要去修改原有的代码，而是扩展原有代码，实现一个热插拔的效果。</p>
<ol start="2">
<li>单一职责原则</li>
</ol>
<p>不要存在多于一个导致类变更的原因，也就是说每个类的职责应该单一，否则就应该把类进行拆分。</p>
<ol start="3">
<li>里氏替换原则</li>
</ol>
<p>任何引用基类的地方必须能透明地使用其子类的对象。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，
而衍生类也能够在基类的基础上增加新的行为。</p>
<ol start="4">
<li>依赖倒转原则</li>
</ol>
<p>面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不要直接与具体类交互，而与具体类的上层接口交互。</p>
<ol start="5">
<li>接口隔离原则</li>
</ol>
<p>每个接口中不存在子类用不到却必须实现的方法，否则，就应该将接口拆分，使用多个隔离的接口。</p>
<ol start="6">
<li>迪米特法则（最少知道原则）</li>
</ol>
<p>一个类对自己依赖的类知道的越少越好，无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p>
<h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><ol>
<li>创建型模式</li>
</ol>
<p>工厂模式、单例模式、建造者模式、原型模式等</p>
<ol start="2">
<li>结构型模式</li>
</ol>
<p>适配器模式、组合模式、装饰器模式、代理模式、门面模式、桥接模式、享元模式等</p>
<ol start="3">
<li>行为型模式</li>
</ol>
<p>策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、访问者模式、调停者模式等</p>
<h3 id="设计模式的使用"><a href="#设计模式的使用" class="headerlink" title="设计模式的使用"></a>设计模式的使用</h3><p>设计模式的目标在于保证程序的高可用以及高扩展性，在实际开发的过程中不应过多地纠结使用哪种设计模式，而是应该多体会设计模式的原则，换言之，
只要遵循一定的原则，这些所谓的模式完全可能在无意识的状态下自发出现在产品代码中。其实这些设计模式也不是谁突然间硬想出来的，而是早已存在并广泛使用的做法，它们来自于好的做法的总结。  </p>
<p>好的设计能够有效地避免或者延缓程序<font color="red">架构的腐化</font>，通常，很多程序一开始的结构也许设计得还可以，但随着业务功能的不断扩展和变化，
可能就不得不在结构上做出一些妥协让步，慢慢地也就失去了结构。<br>但是，在设计过程中需要注意避免<font color="red">过度设计</font>，即为可能发生的变动支付了过多的复杂度代价。不要滥用设计模式，觉得一个地方有可能会变动，
就忍不住考虑是否应该增加复杂度来换取灵活性。要避免过度设计，关键在于能正确的预见变化，以及权衡所引入的复杂度相对于发生变化的可能性和破坏力是否值得，这需要经验的积累以及对业务的认识。</p>
<h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h2><p>单例模式的意思就是确保某个类在系统中只有一个实例，概括起来即以下三点：</p>
<ol>
<li>只能有一个类实例；</li>
<li>类必须自行创建这个实例；</li>
<li>类必须自行向整个系统提供这个实例。<a id="more"></a>

</li>
</ol>
<h3 id="1-1-饿汉式"><a href="#1-1-饿汉式" class="headerlink" title="1.1. 饿汉式"></a>1.1. 饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java初始器中采用了特殊的方式来处理静态域，并提供了额外的线程安全性保证：<font color="green">静态初始化器是由JVM在类的初始化阶段执行，即在类被加载后且被线程使用之前。
由于JVM将在初始化期间获得一个锁，并且每个线程都至少获取一次这个锁以确保这个类已经加载，因此在静态初始化期间，内存写入操作将自动对所有线程可见。
因此无论是在被构造期间还是被引用时，静态初始化的对象都不需要显示的同步。</font><br>不过，这仅适用于在构造时的状态，如果对象是可变的，那么在读线程和写线程之间仍然需要通过同步来确保随后的修改操作是可见的，以避免数据破坏。</p>
<h3 id="1-2-懒汉式"><a href="#1-2-懒汉式" class="headerlink" title="1.2. 懒汉式"></a>1.2. 懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式很简单，由私有构造器和一个公有静态工厂构成，在工厂方法中对<code>singleton</code>进行null判断，如果是null就<code>new</code>一个出来。考虑线程安全，
对<code>singleton</code>的null判断以及<code>new</code>的部分使用<code>synchronized</code>进行加锁，但这显然会降低程序的性能。    </p>
<p>如果<code>getInstance()</code>不会被多个线程频繁调用，即不存在激烈的竞争，那么由于<code>getInstance()</code>的代码路径很短，也许性能上还可以接受，
但在早期JVM中（性能上还存在一些有待优化的地方，比如1.5及之前），哪怕没有竞争的同步也存在着巨大的性能开销。</p>
<h3 id="1-3-双重检查锁"><a href="#1-3-双重检查锁" class="headerlink" title="1.3. 双重检查锁"></a>1.3. 双重检查锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">               singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的初衷是对懒汉式进行改进：考虑到大多数情况下都是获取一个已经存在的实例，因此可以应该尽量避免同步的消耗。</p>
<p>但要注意的是，需要加上<code>volatile</code>修饰，来防止运行时对语句的重排序。由于对实例状态的第一次判断没有使用同步（不具备可见性条件），那么在多线程环境下，
其他线程很可能看到一个已经赋值但还没初始化完成的<code>singleton</code>实例。</p>
<h3 id="1-4-静态内部类"><a href="#1-4-静态内部类" class="headerlink" title="1.4. 静态内部类"></a>1.4. 静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在《java并发编程实战》中称为延长初始化占位类模式，它使用一个专门的内部静态类来初始化Singleton，因为JVM会推迟类的加载和初始化，直到使用时才进行。
当任何一个线程第一次调用<code>getInstance()</code>时，都会触发<code>Holder</code>被加载和初始化，此时静态初始化器将执行<code>Singleton</code>的初始化操作。<br>不过可以知道，如果除了<code>getInstance()</code>之外没有别的调用导致类加载和初始化的话，那么它与饿汉式并没有区别。</p>
<h3 id="1-5-枚举类"><a href="#1-5-枚举类" class="headerlink" title="1.5. 枚举类"></a>1.5. 枚举类</h3><p>在看枚举方式之前，先看下上面四种方式都存在的两个问题：需要额外的工作来实现序列化，否则每次反序列化时都会创建一个新的实例；另外阻止不了反射强行调用私有构造器，
一种办法是修改构造器，让它再次创建时抛异常。而枚举除了线程安全和防止反射强行调用构造器之外，还提供了自动序列化机制，并且能防止反序列化的时候创建新的对象，
因此，《Effective Java》中也推荐使用枚举类的方式来实现单例。</p>
<h4 id="1-5-1-序列化"><a href="#1-5-1-序列化" class="headerlink" title="1.5.1 序列化"></a>1.5.1 序列化</h4><p>对于上面任意的方式，我们都可以使用序列化的方式来重复创建新的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123; </span><br><span class="line"></span><br><span class="line">	Singleton singleton = Singleton.getInstance();</span><br><span class="line">	</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"singleton_file"</span>));</span><br><span class="line">    oos.writeObject(singleton); </span><br><span class="line"></span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"singleton_file"</span>));</span><br><span class="line">    Singleton newSingleton = (Singleton) ois.readObject(); </span><br><span class="line"></span><br><span class="line">    System.out.println(singleton);</span><br><span class="line">    System.out.println(newSingleton);</span><br><span class="line">    System.out.println(singleton == newSingleton);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">demo.Singleton@5c647e05</span><br><span class="line">demo.Singleton@33909752</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>如果要避免这个问题，可以自定义一个<code>readResolve()</code>，在其中返回类的单例对象，替换掉<code>readObject()</code>方法反序列化生成的对象，以方式4为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5255871411862392263L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Holder.singleton;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Holder.singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-2-反射"><a href="#1-5-2-反射" class="headerlink" title="1.5.2 反射"></a>1.5.2 反射</h4><p>单例模式中，构造器都是私有的，但反射可以通过构造器<code>setAccessible(true)</code>来获得权限，以便创建多个对象，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Singleton instance = Singleton.getInstance();</span><br><span class="line">	Constructor&lt;Singleton&gt; constructor = Singleton<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;</span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);    </span><br><span class="line">    Singleton newInstance = (Singleton) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">    System.out.println(instance);</span><br><span class="line">    System.out.println(newInstance);</span><br><span class="line">    System.out.println(instance == newInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">demo.Singleton@15db9742</span><br><span class="line">demo.Singleton@6d06d69c</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>一种解决办法是在构造器中检测是否已经创建过实例，如果是则抛出异常，比如：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;   </span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(singleton != <span class="keyword">null</span>)&#123;</span><br><span class="line">    		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"禁止实例化!"</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这也只对饿汉式起作用，其他的方式只要在第一次调用<code>getInstance()</code>之前，那么就可以无限制反射创建实例。</p>
<h4 id="1-5-3-枚举的实现"><a href="#1-5-3-枚举的实现" class="headerlink" title="1.5.3 枚举的实现"></a>1.5.3 枚举的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">	</span><br><span class="line">	INSTANCE(<span class="string">"singleton"</span>, <span class="number">20</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">	</span><br><span class="line">	Singleton(String name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.value = age;</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(name);</span><br><span class="line">		System.out.println(value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，enum是由class实现的，就是说enum可以实现很多class的内容，包括属性和方法，这也是我们可以用enum作为一个类来实现单例的基础，其次，它继承了Enum。<br>可以通过java自带的命令javap来看下枚举类的class，比如<code>javap -p Singleton.class</code>。不过通过反编译工具<code>jad -sjava Singleton.class</code>可以看到class更加完整的内容(
下载地址: <a href="http://www.javadecompilers.com/jad" target="_blank" rel="noopener">http://www.javadecompilers.com/jad</a>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(String s, <span class="keyword">int</span> i, String name, <span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        value = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        Singleton asingleton[];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        Singleton asingleton1[];</span><br><span class="line">        System.arraycopy(asingleton = ENUM$VALUES, <span class="number">0</span>, asingleton1 = <span class="keyword">new</span> Singleton[i = asingleton.length], <span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">return</span> asingleton1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Singleton)Enum.valueOf(demo/Singleton, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton ENUM$VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton(<span class="string">"INSTANCE"</span>, <span class="number">0</span>, <span class="string">"demo"</span>, <span class="number">20</span>);</span><br><span class="line">        ENUM$VALUES = (<span class="keyword">new</span> Singleton[] &#123;</span><br><span class="line">            INSTANCE</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，枚举类的实例是<code>static final</code>修饰的，在静态域中初始化，并且它的构造器私有，因此它天然就是一个单例的实现，相当于饿汉式。再来看它是如何避免序列化和反射破坏的。</p>
<h5 id="1-5-3-1-枚举类的序列化"><a href="#1-5-3-1-枚举类的序列化" class="headerlink" title="1.5.3.1 枚举类的序列化"></a>1.5.3.1 枚举类的序列化</h5><p>为了保证枚举类型像Java规范中所说的那样，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定：</p>
<blockquote>
<p>Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; 
field values of the constant are not present in the form. To serialize an enum constant, ObjectOutputStream writes the value returned by the enum constant’s name 
method. To deserialize an enum constant, ObjectInputStream reads the constant name from the stream; the deserialized constant is then obtained by calling the 
java.lang.Enum.valueOf method, passing the constant’s enum type along with the received constant name as arguments. Like other serializable or externalizable 
objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream. The process by which enum constants 
are serialized cannot be customized: any class-specific writeObject, readObject, readObjectNoData, writeReplace, and readResolve methods defined by enum types 
are ignored during serialization and deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored–all enum 
types have a fixedserialVersionUID of 0L. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of 
data sent.</p>
</blockquote>
<p>大意是说：<font color="green">在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的<code>valueOf()</code>方法来根据名字查找枚举对象。</font>
同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了<code>writeObject</code>、<code>readObject</code>、<code>readObjectNoData</code>、<code>writeReplace</code>和<code>readResolve</code>等方法。</p>
<p>可以看下Enum中<code>valueOf()</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType, String name)</span> </span>&#123;</span><br><span class="line">	T result = enumType.enumConstantDirectory().get(name);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (name == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Name is null"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">			<span class="string">"No enum constant "</span> + enumType.getCanonicalName() + <span class="string">"."</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看Class中的实现就知道，它首先尝试从内存中维护的实例Map通过名字获取，如果Map为空就通过反射调用<code>values()</code>进行初始化，而<code>values()</code>中的值就是static静态域中初始化的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> Map&lt;String, T&gt; enumConstantDirectory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Map&lt;String, T&gt; <span class="title">enumConstantDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (enumConstantDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">		T[] universe = getEnumConstantsShared();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (universe == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(getName() + <span class="string">" is not an enum type"</span>);</span><br><span class="line">		</span><br><span class="line">		Map&lt;String, T&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span> * universe.length);</span><br><span class="line">		<span class="keyword">for</span> (T constant : universe)</span><br><span class="line">			m.put(((Enum&lt;?&gt;)constant).name(), constant);</span><br><span class="line">		</span><br><span class="line">		enumConstantDirectory = m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> enumConstantDirectory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T[] getEnumConstantsShared() &#123;</span><br><span class="line">	<span class="keyword">if</span> (enumConstants == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isEnum()) </span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">final</span> Method values = getMethod(<span class="string">"values"</span>);</span><br><span class="line">			java.security.AccessController.doPrivileged(</span><br><span class="line">					<span class="keyword">new</span> java.security.PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">						<span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">							values.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">							<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line"></span><br><span class="line">			<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">			T[] temporaryConstants = (T[])values.invoke(<span class="keyword">null</span>);</span><br><span class="line">			enumConstants = temporaryConstants;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// These can happen when users concoct enum-like classes</span></span><br><span class="line">		<span class="comment">// that don't comply with the enum spec.</span></span><br><span class="line">		<span class="keyword">catch</span> (InvocationTargetException | NoSuchMethodException |</span><br><span class="line">				IllegalAccessException ex) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> enumConstants;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-5-3-2-枚举类的反射"><a href="#1-5-3-2-枚举类的反射" class="headerlink" title="1.5.3.2 枚举类的反射"></a>1.5.3.2 枚举类的反射</h5><p>再看<code>Constructor</code>类的<code>newInstance</code>方法，其中会判断是否为enum，如果是则抛出异常，因此枚举类不支持反射。</p>
<figure class="highlight java"><figcaption><span class="caption">java.lang.reflect.Constructor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">		IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!override) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">			Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">			checkAccess(caller, clazz, <span class="keyword">null</span>, modifiers);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</span><br><span class="line">		</span><br><span class="line">	ConstructorAccessor ca = constructorAccessor;   <span class="comment">// read volatile</span></span><br><span class="line">	<span class="keyword">if</span> (ca == <span class="keyword">null</span>) &#123;</span><br><span class="line">		ca = acquireConstructorAccessor();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	T inst = (T) ca.newInstance(initargs);</span><br><span class="line">	<span class="keyword">return</span> inst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-应用"><a href="#2-应用" class="headerlink" title="2. 应用"></a>2. 应用</h2><h3 id="2-1-java-Runtime"><a href="#2-1-java-Runtime" class="headerlink" title="2.1. java Runtime"></a>2.1. java Runtime</h3><p>JDK Runtime类代表着Java程序的运行时环境，每个Java程序都有一个Runtime实例，可以通过<code>Runtime.getRuntime()</code>方法来获取当前程序的Runtime实例。一旦得到了一个当前的Runtime对象的引用，
就可以调用Runtime对象的方法去控制Java虚拟机的状态和行为。</p>
<figure class="highlight java"><figcaption><span class="caption">java.lang.Runtime</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-spring-AbstractFactoryBean"><a href="#2-2-spring-AbstractFactoryBean" class="headerlink" title="2.2. spring AbstractFactoryBean"></a>2.2. spring AbstractFactoryBean</h3><figure class="highlight java"><figcaption><span class="caption">org.springframework.beans.factory.config.AbstractFactoryBean</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isSingleton()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.initialized ? <span class="keyword">this</span>.singletonInstance : <span class="keyword">this</span>.getEarlySingletonInstance();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.createInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">getEarlySingletonInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Class&lt;?&gt;[] ifcs = <span class="keyword">this</span>.getEarlySingletonInterfaces();</span><br><span class="line">	<span class="keyword">if</span> (ifcs == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> FactoryBeanNotInitializedException(<span class="keyword">this</span>.getClass().getName() </span><br><span class="line">				+ <span class="string">" does not support circular references"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.earlySingletonInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.earlySingletonInstance = (T)Proxy.newProxyInstance(<span class="keyword">this</span>.beanClassLoader, </span><br><span class="line">					ifcs, <span class="keyword">new</span> AbstractFactoryBean.EarlySingletonInvocationHandler());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.earlySingletonInstance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-mybatis-ErrorContext"><a href="#2-3-mybatis-ErrorContext" class="headerlink" title="2.3. mybatis ErrorContext"></a>2.3. mybatis ErrorContext</h3><p>ErrorContext类，通过ThreadLocal管理实例，保证线程安全，一个线程一个ErrorContext对象。</p>
<figure class="highlight java"><figcaption><span class="caption">org.apache.ibatis.executor.ErrorContext</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ErrorContext&gt; LOCAL = <span class="keyword">new</span> ThreadLocal&lt;ErrorContext&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ErrorContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ErrorContext <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ErrorContext context = LOCAL.get();</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">          context = <span class="keyword">new</span> ErrorContext();</span><br><span class="line">          LOCAL.set(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><strong>参考：</strong></p>
<ol>
<li>《java与模式》    </li>
<li>《java并发编程实战》    </li>
<li><a href="http://www.hollischuang.com/archives/197" target="_blank" rel="noopener">http://www.hollischuang.com/archives/197</a>    </li>
<li><a href="https://www.cnblogs.com/chiclee/p/9097772.html" target="_blank" rel="noopener">https://www.cnblogs.com/chiclee/p/9097772.html</a>    </li>
<li><a href="https://blog.csdn.net/abc123lzf/article/details/82318148" target="_blank" rel="noopener">https://blog.csdn.net/abc123lzf/article/details/82318148</a>     </li>
<li><a href="https://www.cnblogs.com/cielosun/p/6596475.html" target="_blank" rel="noopener">https://www.cnblogs.com/cielosun/p/6596475.html</a>     </li>
</ol>

      
    </div>
	
	
	
    <footer>
      
	  
	    
	<nav id="pagination">
	  
		  <a class="alignleft prev" href="/2017/10/02/20171002/">
		    设计模式. 工厂模式
		  </a>
	  
	  
	  
		  <a class="alignright next" href="/2017/09/12/20170912/">
		    java基础. 容器三. TreeMap以及Set
		  </a>
	  
	  <div class="clearfix"></div>
	</nav>
	
	    
        
  
  <div class="categories">
    <a href="/categories/设计模式/">设计模式</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/单例模式/">单例模式</a>, <a href="/tags/枚举/">枚举</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'd7beb7890a79c73a3e3d',
        clientSecret: '80ea1fc195ae4b80cbd65ec9f1ce68d59595af4b',
        id: md5(window.location.pathname),
        repo: 'shanhm1991.github.io',
        owner: 'shanhm1991',
        admin: 'shanhm1991'
    })
    gitalk.render('gitalk-container')
</script>                              



</div></div>
    <aside id="sidebar" class="alignright">
  


  

  

  

  
<div class="widget catlog">
<h3 class="title">Catlog</h3>
<ul class="entry_catlog">
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#设计模式的原则"><span class="toc-text">设计模式的原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计模式的分类"><span class="toc-text">设计模式的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计模式的使用"><span class="toc-text">设计模式的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-单例模式"><span class="toc-text">1. 单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-饿汉式"><span class="toc-text">1.1. 饿汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-懒汉式"><span class="toc-text">1.2. 懒汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-双重检查锁"><span class="toc-text">1.3. 双重检查锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-静态内部类"><span class="toc-text">1.4. 静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-枚举类"><span class="toc-text">1.5. 枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-序列化"><span class="toc-text">1.5.1 序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-反射"><span class="toc-text">1.5.2 反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-枚举的实现"><span class="toc-text">1.5.3 枚举的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-5-3-1-枚举类的序列化"><span class="toc-text">1.5.3.1 枚举类的序列化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-5-3-2-枚举类的反射"><span class="toc-text">1.5.3.2 枚举类的反射</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-应用"><span class="toc-text">2. 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-java-Runtime"><span class="toc-text">2.1. java Runtime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-spring-AbstractFactoryBean"><span class="toc-text">2.2. spring AbstractFactoryBean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-mybatis-ErrorContext"><span class="toc-text">2.3. mybatis ErrorContext</span></a></li></ol></li></ol>
</div>




</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2020 shanhm1991 
  
  <font style="float: right">
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
